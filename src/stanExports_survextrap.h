// Generated by rstantools.  Do not edit by hand.

/*
    survextrap is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    survextrap is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with survextrap.  If not, see <http://www.gnu.org/licenses/>.
*/
#ifndef MODELS_HPP
#define MODELS_HPP
#define STAN__SERVICES__COMMAND_HPP
#ifndef USE_STANC3
#define USE_STANC3
#endif
#include <rstan/rstaninc.hpp>
// Code generated by stanc v2.26.1-1-g67504470
#include <stan/model/model_header.hpp>
namespace model_survextrap_namespace {
inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}
inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}
using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math;
using stan::math::pow; 
stan::math::profile_map profiles__;
static int current_statement__= 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'string', line 150, column 2 to column 16)",
                                                      " (in 'string', line 151, column 2 to column 22)",
                                                      " (in 'string', line 152, column 2 to column 27)",
                                                      " (in 'string', line 153, column 2 to column 40)",
                                                      " (in 'string', line 154, column 2 to column 38)",
                                                      " (in 'string', line 155, column 2 to column 31)",
                                                      " (in 'string', line 158, column 4 to column 23)",
                                                      " (in 'string', line 159, column 4 to column 24)",
                                                      " (in 'string', line 163, column 1 to column 63)",
                                                      " (in 'string', line 161, column 1 to column 57)",
                                                      " (in 'string', line 160, column 4 to line 163, column 63)",
                                                      " (in 'string', line 167, column 1 to column 29)",
                                                      " (in 'string', line 168, column 1 to column 14)",
                                                      " (in 'string', line 166, column 11 to line 169, column 5)",
                                                      " (in 'string', line 165, column 1 to column 23)",
                                                      " (in 'string', line 164, column 19 to line 166, column 5)",
                                                      " (in 'string', line 164, column 4 to line 169, column 5)",
                                                      " (in 'string', line 240, column 4 to column 49)",
                                                      " (in 'string', line 172, column 11 to column 17)",
                                                      " (in 'string', line 172, column 4 to column 29)",
                                                      " (in 'string', line 173, column 11 to column 17)",
                                                      " (in 'string', line 173, column 4 to column 29)",
                                                      " (in 'string', line 174, column 11 to column 18)",
                                                      " (in 'string', line 174, column 4 to column 31)",
                                                      " (in 'string', line 175, column 4 to column 15)",
                                                      " (in 'string', line 176, column 4 to column 12)",
                                                      " (in 'string', line 177, column 11 to column 18)",
                                                      " (in 'string', line 177, column 4 to column 31)",
                                                      " (in 'string', line 178, column 11 to column 18)",
                                                      " (in 'string', line 178, column 4 to column 32)",
                                                      " (in 'string', line 179, column 11 to column 17)",
                                                      " (in 'string', line 179, column 4 to column 31)",
                                                      " (in 'string', line 180, column 11 to column 17)",
                                                      " (in 'string', line 180, column 4 to column 31)",
                                                      " (in 'string', line 181, column 11 to column 18)",
                                                      " (in 'string', line 181, column 4 to column 33)",
                                                      " (in 'string', line 188, column 17 to column 53)",
                                                      " (in 'string', line 188, column 1 to column 53)",
                                                      " (in 'string', line 189, column 17 to column 53)",
                                                      " (in 'string', line 189, column 1 to column 53)",
                                                      " (in 'string', line 190, column 18 to column 56)",
                                                      " (in 'string', line 190, column 1 to column 56)",
                                                      " (in 'string', line 187, column 11 to line 191, column 5)",
                                                      " (in 'string', line 184, column 17 to column 45)",
                                                      " (in 'string', line 184, column 1 to column 45)",
                                                      " (in 'string', line 185, column 17 to column 45)",
                                                      " (in 'string', line 185, column 1 to column 45)",
                                                      " (in 'string', line 186, column 18 to column 45)",
                                                      " (in 'string', line 186, column 1 to column 45)",
                                                      " (in 'string', line 182, column 19 to line 187, column 5)",
                                                      " (in 'string', line 182, column 4 to line 191, column 5)",
                                                      " (in 'string', line 193, column 20 to column 54)",
                                                      " (in 'string', line 193, column 4 to column 54)",
                                                      " (in 'string', line 194, column 20 to column 54)",
                                                      " (in 'string', line 194, column 4 to column 54)",
                                                      " (in 'string', line 195, column 21 to column 56)",
                                                      " (in 'string', line 195, column 4 to column 56)",
                                                      " (in 'string', line 198, column 20 to column 42)",
                                                      " (in 'string', line 198, column 4 to column 42)",
                                                      " (in 'string', line 199, column 20 to column 42)",
                                                      " (in 'string', line 199, column 4 to column 42)",
                                                      " (in 'string', line 200, column 21 to column 44)",
                                                      " (in 'string', line 200, column 4 to column 44)",
                                                      " (in 'string', line 201, column 34 to column 41)",
                                                      " (in 'string', line 201, column 14 to column 28)",
                                                      " (in 'string', line 201, column 4 to column 41)",
                                                      " (in 'string', line 202, column 4 to column 41)",
                                                      " (in 'string', line 203, column 4 to column 41)",
                                                      " (in 'string', line 204, column 4 to column 43)",
                                                      " (in 'string', line 207, column 17 to column 88)",
                                                      " (in 'string', line 207, column 1 to column 88)",
                                                      " (in 'string', line 208, column 17 to column 88)",
                                                      " (in 'string', line 208, column 1 to column 88)",
                                                      " (in 'string', line 209, column 18 to column 89)",
                                                      " (in 'string', line 209, column 1 to column 89)",
                                                      " (in 'string', line 206, column 22 to line 210, column 5)",
                                                      " (in 'string', line 206, column 4 to line 210, column 5)",
                                                      " (in 'string', line 211, column 20 to column 114)",
                                                      " (in 'string', line 211, column 4 to column 114)",
                                                      " (in 'string', line 212, column 20 to column 100)",
                                                      " (in 'string', line 212, column 4 to column 100)",
                                                      " (in 'string', line 214, column 1 to column 93)",
                                                      " (in 'string', line 215, column 1 to column 95)",
                                                      " (in 'string', line 216, column 1 to column 67)",
                                                      " (in 'string', line 213, column 21 to line 217, column 5)",
                                                      " (in 'string', line 213, column 4 to line 217, column 5)",
                                                      " (in 'string', line 220, column 4 to line 225, column 9)",
                                                      " (in 'string', line 228, column 1 to column 27)",
                                                      " (in 'string', line 227, column 19 to line 229, column 5)",
                                                      " (in 'string', line 227, column 4 to line 229, column 5)",
                                                      " (in 'string', line 232, column 1 to column 44)",
                                                      " (in 'string', line 231, column 14 to line 233, column 5)",
                                                      " (in 'string', line 231, column 4 to line 233, column 5)",
                                                      " (in 'string', line 235, column 1 to column 25)",
                                                      " (in 'string', line 234, column 19 to line 236, column 5)",
                                                      " (in 'string', line 234, column 4 to line 236, column 5)",
                                                      " (in 'string', line 118, column 2 to column 22)",
                                                      " (in 'string', line 119, column 2 to column 22)",
                                                      " (in 'string', line 120, column 2 to column 21)",
                                                      " (in 'string', line 121, column 2 to column 23)",
                                                      " (in 'string', line 122, column 2 to column 21)",
                                                      " (in 'string', line 123, column 2 to column 25)",
                                                      " (in 'string', line 125, column 2 to column 28)",
                                                      " (in 'string', line 127, column 9 to column 15)",
                                                      " (in 'string', line 127, column 16 to column 21)",
                                                      " (in 'string', line 127, column 2 to column 35)",
                                                      " (in 'string', line 128, column 9 to column 15)",
                                                      " (in 'string', line 128, column 16 to column 21)",
                                                      " (in 'string', line 128, column 2 to column 36)",
                                                      " (in 'string', line 129, column 9 to column 15)",
                                                      " (in 'string', line 129, column 16 to column 21)",
                                                      " (in 'string', line 129, column 2 to column 36)",
                                                      " (in 'string', line 130, column 9 to column 16)",
                                                      " (in 'string', line 130, column 17 to column 22)",
                                                      " (in 'string', line 130, column 2 to column 40)",
                                                      " (in 'string', line 131, column 9 to column 16)",
                                                      " (in 'string', line 131, column 17 to column 22)",
                                                      " (in 'string', line 131, column 2 to column 41)",
                                                      " (in 'string', line 132, column 9 to column 15)",
                                                      " (in 'string', line 132, column 16 to column 21)",
                                                      " (in 'string', line 132, column 2 to column 31)",
                                                      " (in 'string', line 133, column 9 to column 15)",
                                                      " (in 'string', line 133, column 16 to column 21)",
                                                      " (in 'string', line 133, column 2 to column 31)",
                                                      " (in 'string', line 134, column 9 to column 15)",
                                                      " (in 'string', line 134, column 16 to column 25)",
                                                      " (in 'string', line 134, column 2 to column 39)",
                                                      " (in 'string', line 135, column 9 to column 15)",
                                                      " (in 'string', line 135, column 16 to column 25)",
                                                      " (in 'string', line 135, column 2 to column 39)",
                                                      " (in 'string', line 138, column 21 to column 28)",
                                                      " (in 'string', line 138, column 2 to column 30)",
                                                      " (in 'string', line 139, column 21 to column 28)",
                                                      " (in 'string', line 139, column 2 to column 30)",
                                                      " (in 'string', line 140, column 9 to column 16)",
                                                      " (in 'string', line 140, column 17 to column 22)",
                                                      " (in 'string', line 140, column 2 to column 30)",
                                                      " (in 'string', line 141, column 9 to column 16)",
                                                      " (in 'string', line 141, column 17 to column 26)",
                                                      " (in 'string', line 141, column 2 to column 38)",
                                                      " (in 'string', line 142, column 9 to column 16)",
                                                      " (in 'string', line 142, column 2 to column 28)",
                                                      " (in 'string', line 143, column 2 to column 17)",
                                                      " (in 'string', line 144, column 18 to column 30)",
                                                      " (in 'string', line 144, column 2 to column 48)",
                                                      " (in 'string', line 145, column 2 to column 11)",
                                                      " (in 'string', line 146, column 2 to column 32)",
                                                      " (in 'string', line 147, column 2 to column 14)",
                                                      " (in 'string', line 150, column 13 to column 14)",
                                                      " (in 'string', line 151, column 9 to column 14)",
                                                      " (in 'string', line 152, column 9 to column 16)",
                                                      " (in 'string', line 153, column 18 to column 28)",
                                                      " (in 'string', line 154, column 26 to column 30)",
                                                      " (in 'string', line 155, column 9 to column 18)",
                                                      " (in 'string', line 158, column 11 to column 16)",
                                                      " (in 'string', line 159, column 11 to column 16)",
                                                      " (in 'string', line 12, column 4 to column 36)",
                                                      " (in 'string', line 11, column 65 to line 13, column 3)",
                                                      " (in 'string', line 23, column 11 to column 20)",
                                                      " (in 'string', line 23, column 4 to column 26)",
                                                      " (in 'string', line 24, column 4 to column 41)",
                                                      " (in 'string', line 26, column 1 to column 85)",
                                                      " (in 'string', line 25, column 25 to line 27, column 5)",
                                                      " (in 'string', line 25, column 4 to line 27, column 5)",
                                                      " (in 'string', line 28, column 4 to column 15)",
                                                      " (in 'string', line 22, column 67 to line 29, column 3)",
                                                      " (in 'string', line 31, column 8 to column 17)",
                                                      " (in 'string', line 31, column 1 to column 23)",
                                                      " (in 'string', line 33, column 1 to line 34, column 42)",
                                                      " (in 'string', line 35, column 1 to column 12)",
                                                      " (in 'string', line 30, column 83 to line 36, column 5)",
                                                      " (in 'string', line 39, column 8 to column 17)",
                                                      " (in 'string', line 39, column 1 to column 23)",
                                                      " (in 'string', line 40, column 8 to column 17)",
                                                      " (in 'string', line 40, column 1 to column 32)",
                                                      " (in 'string', line 45, column 2 to column 71)",
                                                      " (in 'string', line 44, column 28 to line 46, column 6)",
                                                      " (in 'string', line 44, column 5 to line 46, column 6)",
                                                      " (in 'string', line 43, column 24 to line 47, column 2)",
                                                      " (in 'string', line 43, column 8 to line 47, column 2)",
                                                      " (in 'string', line 42, column 5 to column 57)",
                                                      " (in 'string', line 41, column 16 to line 43, column 2)",
                                                      " (in 'string', line 41, column 1 to line 47, column 2)",
                                                      " (in 'string', line 53, column 5 to column 24)",
                                                      " (in 'string', line 52, column 8 to line 54, column 2)",
                                                      " (in 'string', line 50, column 2 to column 63)",
                                                      " (in 'string', line 49, column 28 to line 51, column 6)",
                                                      " (in 'string', line 49, column 5 to line 51, column 6)",
                                                      " (in 'string', line 48, column 11 to line 52, column 2)",
                                                      " (in 'string', line 48, column 1 to line 54, column 2)",
                                                      " (in 'string', line 55, column 1 to column 12)",
                                                      " (in 'string', line 38, column 108 to line 56, column 5)",
                                                      " (in 'string', line 60, column 8 to column 17)",
                                                      " (in 'string', line 60, column 1 to column 23)",
                                                      " (in 'string', line 61, column 8 to column 17)",
                                                      " (in 'string', line 61, column 1 to column 32)",
                                                      " (in 'string', line 62, column 8 to column 17)",
                                                      " (in 'string', line 62, column 1 to column 31)",
                                                      " (in 'string', line 63, column 8 to column 17)",
                                                      " (in 'string', line 63, column 1 to column 32)",
                                                      " (in 'string', line 81, column 6 to line 82, column 54)",
                                                      " (in 'string', line 80, column 24 to line 83, column 3)",
                                                      " (in 'string', line 80, column 2 to line 83, column 3)",
                                                      " (in 'string', line 79, column 12 to line 84, column 6)",
                                                      " (in 'string', line 78, column 2 to column 51)",
                                                      " (in 'string', line 77, column 20 to line 79, column 6)",
                                                      " (in 'string', line 77, column 5 to line 84, column 6)",
                                                      " (in 'string', line 85, column 5 to column 23)",
                                                      " (in 'string', line 76, column 8 to line 86, column 2)",
                                                      " (in 'string', line 69, column 6 to column 73)",
                                                      " (in 'string', line 68, column 24 to line 70, column 3)",
                                                      " (in 'string', line 68, column 2 to line 70, column 3)",
                                                      " (in 'string', line 67, column 12 to line 71, column 6)",
                                                      " (in 'string', line 66, column 2 to column 61)",
                                                      " (in 'string', line 65, column 20 to line 67, column 6)",
                                                      " (in 'string', line 65, column 5 to line 71, column 6)",
                                                      " (in 'string', line 72, column 5 to column 71)",
                                                      " (in 'string', line 74, column 2 to column 65)",
                                                      " (in 'string', line 73, column 27 to line 75, column 6)",
                                                      " (in 'string', line 73, column 5 to line 75, column 6)",
                                                      " (in 'string', line 64, column 11 to line 76, column 2)",
                                                      " (in 'string', line 64, column 1 to line 86, column 2)",
                                                      " (in 'string', line 87, column 1 to column 12)",
                                                      " (in 'string', line 59, column 23 to line 88, column 5)",
                                                      " (in 'string', line 92, column 8 to column 17)",
                                                      " (in 'string', line 92, column 1 to column 23)",
                                                      " (in 'string', line 93, column 1 to line 94, column 56)",
                                                      " (in 'string', line 95, column 1 to column 12)",
                                                      " (in 'string', line 91, column 23 to line 96, column 5)",
                                                      " (in 'string', line 112, column 6 to column 56)",
                                                      " (in 'string', line 111, column 9 to line 112, column 56)",
                                                      " (in 'string', line 110, column 6 to column 49)",
                                                      " (in 'string', line 109, column 4 to line 112, column 56)",
                                                      " (in 'string', line 114, column 4 to column 20)",
                                                      " (in 'string', line 108, column 70 to line 115, column 3)"};
template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>, stan::value_type_t<T1__>,
stan::value_type_t<T2__>>, -1, 1>
mspline_log_haz(const T0__& eta_arg__, const T1__& basis_arg__,
                const T2__& coefs_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>,
          stan::value_type_t<T1__>,
          stan::value_type_t<T2__>>;
  const auto& eta = to_ref(eta_arg__);
  const auto& basis = to_ref(basis_arg__);
  const auto& coefs = to_ref(coefs_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 157;
    return add(stan::math::log(multiply(basis, coefs)), eta);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct mspline_log_haz_functor__ {
template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>, stan::value_type_t<T1__>,
stan::value_type_t<T2__>>, -1, 1>
operator()(const T0__& eta, const T1__& basis, const T2__& coefs,
           std::ostream* pstream__)  const 
{
return mspline_log_haz(eta, basis, coefs, pstream__);
}
};
template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>, stan::value_type_t<T1__>,
stan::value_type_t<T2__>>, -1, 1>
mspline_log_surv(const T0__& eta_arg__, const T1__& ibasis_arg__,
                 const T2__& coefs_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>,
          stan::value_type_t<T1__>,
          stan::value_type_t<T2__>>;
  const auto& eta = to_ref(eta_arg__);
  const auto& ibasis = to_ref(ibasis_arg__);
  const auto& coefs = to_ref(coefs_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 159;
    validate_non_negative_index("res", "rows(eta)", rows(eta));
    Eigen::Matrix<local_scalar_t__, -1, 1> res;
    res = Eigen::Matrix<local_scalar_t__, -1, 1>(rows(eta));
    stan::math::fill(res, DUMMY_VAR__);
    
    current_statement__ = 161;
    assign(res, nil_index_list(),
      elt_multiply(minus(multiply(ibasis, coefs)), stan::math::exp(eta)),
      "assigning variable res");
    current_statement__ = 164;
    if (logical_gt(stan::math::exp(res[(1 - 1)]), 1)) {
      current_statement__ = 162;
      std::stringstream errmsg_stream__;
      errmsg_stream__ << "Probability > 1 computed. Not your fault - report a bug to the developer.";
      throw std::domain_error(errmsg_stream__.str());
    } 
    current_statement__ = 165;
    return res;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct mspline_log_surv_functor__ {
template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>, stan::value_type_t<T1__>,
stan::value_type_t<T2__>>, -1, 1>
operator()(const T0__& eta, const T1__& ibasis, const T2__& coefs,
           std::ostream* pstream__)  const 
{
return mspline_log_surv(eta, ibasis, coefs, pstream__);
}
};
template <typename T0__, typename T1__, typename T2__, typename T3__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>, stan::value_type_t<T1__>,
stan::value_type_t<T2__>,
stan::value_type_t<T3__>>, -1, 1>
mspline_log_dens(const T0__& eta_arg__, const T1__& basis_arg__,
                 const T2__& ibasis_arg__, const T3__& coefs_arg__,
                 std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>,
          stan::value_type_t<T1__>,
          stan::value_type_t<T2__>,
          stan::value_type_t<T3__>>;
  const auto& eta = to_ref(eta_arg__);
  const auto& basis = to_ref(basis_arg__);
  const auto& ibasis = to_ref(ibasis_arg__);
  const auto& coefs = to_ref(coefs_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 167;
    validate_non_negative_index("res", "rows(eta)", rows(eta));
    Eigen::Matrix<local_scalar_t__, -1, 1> res;
    res = Eigen::Matrix<local_scalar_t__, -1, 1>(rows(eta));
    stan::math::fill(res, DUMMY_VAR__);
    
    current_statement__ = 169;
    assign(res, nil_index_list(),
      add(mspline_log_haz(eta, basis, coefs, pstream__),
        mspline_log_surv(eta, ibasis, coefs, pstream__)),
      "assigning variable res");
    current_statement__ = 170;
    return res;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct mspline_log_dens_functor__ {
template <typename T0__, typename T1__, typename T2__, typename T3__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>, stan::value_type_t<T1__>,
stan::value_type_t<T2__>,
stan::value_type_t<T3__>>, -1, 1>
operator()(const T0__& eta, const T1__& basis, const T2__& ibasis,
           const T3__& coefs, std::ostream* pstream__)  const 
{
return mspline_log_dens(eta, basis, ibasis, coefs, pstream__);
}
};
template <typename T0__, typename T1__, typename T2__, typename T4__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>, stan::value_type_t<T1__>,
stan::value_type_t<T2__>,
stan::value_type_t<T4__>>, -1, 1>
log_surv(const T0__& eta_arg__, const T1__& ibasis_arg__,
         const T2__& coefs_arg__, const int& cure, const T4__& pcure_arg__,
         const int& modelid, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>,
          stan::value_type_t<T1__>,
          stan::value_type_t<T2__>,
          stan::value_type_t<T4__>>;
  const auto& eta = to_ref(eta_arg__);
  const auto& ibasis = to_ref(ibasis_arg__);
  const auto& coefs = to_ref(coefs_arg__);
  const auto& pcure = to_ref(pcure_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 172;
    validate_non_negative_index("res", "rows(eta)", rows(eta));
    Eigen::Matrix<local_scalar_t__, -1, 1> res;
    res = Eigen::Matrix<local_scalar_t__, -1, 1>(rows(eta));
    stan::math::fill(res, DUMMY_VAR__);
    
    current_statement__ = 174;
    validate_non_negative_index("base_logsurv", "rows(eta)", rows(eta));
    Eigen::Matrix<local_scalar_t__, -1, 1> base_logsurv;
    base_logsurv = Eigen::Matrix<local_scalar_t__, -1, 1>(rows(eta));
    stan::math::fill(base_logsurv, DUMMY_VAR__);
    
    current_statement__ = 183;
    if (logical_eq(modelid, 1)) {
      current_statement__ = 181;
      assign(base_logsurv, nil_index_list(),
        mspline_log_surv(eta, ibasis, coefs, pstream__),
        "assigning variable base_logsurv");
    } else {
      current_statement__ = 180;
      if (logical_eq(modelid, 2)) {
        current_statement__ = 178;
        for (int i = 1; i <= rows(eta); ++i) {
          current_statement__ = 176;
          assign(base_logsurv, cons_list(index_uni(i), nil_index_list()),
            weibull_lccdf(
              rvalue(ibasis,
                cons_list(index_uni(i),
                  cons_list(index_uni(1), nil_index_list())), "ibasis"),
              coefs[(1 - 1)], stan::math::exp(eta[(i - 1)])),
            "assigning variable base_logsurv");}
      } 
    }
    current_statement__ = 190;
    if (cure) {
      current_statement__ = 188;
      for (int i = 1; i <= rows(eta); ++i) {
        current_statement__ = 186;
        assign(res, cons_list(index_uni(i), nil_index_list()),
          stan::math::log(
            (pcure[(i - 1)] +
              ((1 - pcure[(i - 1)]) * stan::math::exp(base_logsurv[(i - 1)])))),
          "assigning variable res");}
    } else {
      current_statement__ = 184;
      assign(res, nil_index_list(), base_logsurv, "assigning variable res");
    }
    current_statement__ = 191;
    return res;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct log_surv_functor__ {
template <typename T0__, typename T1__, typename T2__, typename T4__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>, stan::value_type_t<T1__>,
stan::value_type_t<T2__>,
stan::value_type_t<T4__>>, -1, 1>
operator()(const T0__& eta, const T1__& ibasis, const T2__& coefs,
           const int& cure, const T4__& pcure, const int& modelid,
           std::ostream* pstream__)  const 
{
return log_surv(eta, ibasis, coefs, cure, pcure, modelid, pstream__);
}
};
template <typename T0__, typename T1__, typename T2__, typename T4__,
typename T5__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>, stan::value_type_t<T1__>,
stan::value_type_t<T2__>, stan::value_type_t<T4__>,
stan::value_type_t<T5__>>, -1, 1>
log_haz(const T0__& eta_arg__, const T1__& basis_arg__,
        const T2__& coefs_arg__, const int& cure, const T4__& pcure_arg__,
        const T5__& ibasis_arg__, const int& modelid, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>,
          stan::value_type_t<T1__>,
          stan::value_type_t<T2__>,
          stan::value_type_t<T4__>,
          stan::value_type_t<T5__>>;
  const auto& eta = to_ref(eta_arg__);
  const auto& basis = to_ref(basis_arg__);
  const auto& coefs = to_ref(coefs_arg__);
  const auto& pcure = to_ref(pcure_arg__);
  const auto& ibasis = to_ref(ibasis_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 193;
    validate_non_negative_index("res", "rows(eta)", rows(eta));
    Eigen::Matrix<local_scalar_t__, -1, 1> res;
    res = Eigen::Matrix<local_scalar_t__, -1, 1>(rows(eta));
    stan::math::fill(res, DUMMY_VAR__);
    
    current_statement__ = 195;
    validate_non_negative_index("base_logdens", "rows(eta)", rows(eta));
    Eigen::Matrix<local_scalar_t__, -1, 1> base_logdens;
    base_logdens = Eigen::Matrix<local_scalar_t__, -1, 1>(rows(eta));
    stan::math::fill(base_logdens, DUMMY_VAR__);
    
    current_statement__ = 197;
    validate_non_negative_index("base_loghaz", "rows(eta)", rows(eta));
    Eigen::Matrix<local_scalar_t__, -1, 1> base_loghaz;
    base_loghaz = Eigen::Matrix<local_scalar_t__, -1, 1>(rows(eta));
    stan::math::fill(base_loghaz, DUMMY_VAR__);
    
    current_statement__ = 199;
    validate_non_negative_index("base_logsurv", "rows(eta)", rows(eta));
    Eigen::Matrix<local_scalar_t__, -1, 1> base_logsurv;
    base_logsurv = Eigen::Matrix<local_scalar_t__, -1, 1>(rows(eta));
    stan::math::fill(base_logsurv, DUMMY_VAR__);
    
    current_statement__ = 222;
    if (cure) {
      current_statement__ = 216;
      if (logical_eq(modelid, 1)) {
        current_statement__ = 214;
        assign(base_logdens, nil_index_list(),
          mspline_log_dens(eta, basis, ibasis, coefs, pstream__),
          "assigning variable base_logdens");
      } else {
        current_statement__ = 212;
        for (int i = 1; i <= rows(eta); ++i) {
          current_statement__ = 210;
          assign(base_logdens, cons_list(index_uni(i), nil_index_list()),
            weibull_lpdf<false>(
              rvalue(basis,
                cons_list(index_uni(i),
                  cons_list(index_uni(1), nil_index_list())), "basis"),
              coefs[(1 - 1)], stan::math::exp(eta[(i - 1)])),
            "assigning variable base_logdens");}
      }
      current_statement__ = 217;
      assign(base_logsurv, nil_index_list(),
        log_surv(eta, ibasis, coefs, cure, pcure, modelid, pstream__),
        "assigning variable base_logsurv");
      current_statement__ = 220;
      for (int i = 1; i <= rows(eta); ++i) {
        current_statement__ = 218;
        assign(res, cons_list(index_uni(i), nil_index_list()),
          ((stan::math::log((1 - pcure[(i - 1)])) + base_logdens[(i - 1)]) -
            base_logsurv[(i - 1)]), "assigning variable res");}
    } else {
      current_statement__ = 207;
      if (logical_eq(modelid, 1)) {
        current_statement__ = 205;
        assign(base_loghaz, nil_index_list(),
          mspline_log_haz(eta, basis, coefs, pstream__),
          "assigning variable base_loghaz");
      } else {
        current_statement__ = 203;
        for (int i = 1; i <= rows(eta); ++i) {
          current_statement__ = 201;
          assign(base_loghaz, cons_list(index_uni(i), nil_index_list()),
            (weibull_lpdf<false>(
               rvalue(basis,
                 cons_list(index_uni(i),
                   cons_list(index_uni(1), nil_index_list())), "basis"),
               coefs[(1 - 1)], stan::math::exp(eta[(i - 1)])) -
              weibull_lccdf(
                rvalue(ibasis,
                  cons_list(index_uni(i),
                    cons_list(index_uni(1), nil_index_list())), "ibasis"),
                coefs[(1 - 1)], stan::math::exp(eta[(i - 1)]))),
            "assigning variable base_loghaz");}
      }
      current_statement__ = 208;
      assign(res, nil_index_list(), base_loghaz, "assigning variable res");
    }
    current_statement__ = 223;
    return res;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct log_haz_functor__ {
template <typename T0__, typename T1__, typename T2__, typename T4__,
typename T5__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>, stan::value_type_t<T1__>,
stan::value_type_t<T2__>, stan::value_type_t<T4__>,
stan::value_type_t<T5__>>, -1, 1>
operator()(const T0__& eta, const T1__& basis, const T2__& coefs,
           const int& cure, const T4__& pcure, const T5__& ibasis,
           const int& modelid, std::ostream* pstream__)  const 
{
return log_haz(eta, basis, coefs, cure, pcure, ibasis, modelid, pstream__);
}
};
template <typename T0__, typename T1__, typename T2__, typename T4__,
typename T5__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>, stan::value_type_t<T1__>,
stan::value_type_t<T2__>, stan::value_type_t<T4__>,
stan::value_type_t<T5__>>, -1, 1>
log_dens(const T0__& eta_arg__, const T1__& basis_arg__,
         const T2__& coefs_arg__, const int& cure, const T4__& pcure_arg__,
         const T5__& ibasis_arg__, const int& modelid,
         std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>,
          stan::value_type_t<T1__>,
          stan::value_type_t<T2__>,
          stan::value_type_t<T4__>,
          stan::value_type_t<T5__>>;
  const auto& eta = to_ref(eta_arg__);
  const auto& basis = to_ref(basis_arg__);
  const auto& coefs = to_ref(coefs_arg__);
  const auto& pcure = to_ref(pcure_arg__);
  const auto& ibasis = to_ref(ibasis_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 225;
    validate_non_negative_index("res", "rows(eta)", rows(eta));
    Eigen::Matrix<local_scalar_t__, -1, 1> res;
    res = Eigen::Matrix<local_scalar_t__, -1, 1>(rows(eta));
    stan::math::fill(res, DUMMY_VAR__);
    
    current_statement__ = 227;
    assign(res, nil_index_list(),
      add(
        log_haz(eta, basis, coefs, cure, pcure, ibasis, modelid, pstream__),
        log_surv(eta, ibasis, coefs, cure, pcure, modelid, pstream__)),
      "assigning variable res");
    current_statement__ = 228;
    return res;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct log_dens_functor__ {
template <typename T0__, typename T1__, typename T2__, typename T4__,
typename T5__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>, stan::value_type_t<T1__>,
stan::value_type_t<T2__>, stan::value_type_t<T4__>,
stan::value_type_t<T5__>>, -1, 1>
operator()(const T0__& eta, const T1__& basis, const T2__& coefs,
           const int& cure, const T4__& pcure, const T5__& ibasis,
           const int& modelid, std::ostream* pstream__)  const 
{
return log_dens(eta, basis, coefs, cure, pcure, ibasis, modelid, pstream__);
}
};
template <bool propto__, typename T0__, typename T2__, typename T3__,
typename T4__, typename T_lp__, typename T_lp_accum__>
stan::promote_args_t<T0__, T2__, T3__,
T4__>
gamma_lp(const T0__& gamma, const int& dist, const T2__& mean,
         const T3__& scale, const T4__& df, T_lp__& lp__,
         T_lp_accum__& lp_accum__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T2__, T3__, T4__>;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 233;
    if (logical_eq(dist, 1)) {
      current_statement__ = 232;
      lp_accum__.add(normal_lpdf<false>(gamma, mean, scale));
    } else {
      current_statement__ = 231;
      if (logical_eq(dist, 2)) {
        current_statement__ = 230;
        lp_accum__.add(student_t_lpdf<false>(gamma, df, mean, scale));
      } 
    }
    current_statement__ = 234;
    return get_lp(lp__, lp_accum__);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct gamma_lp_functor__ {
template <bool propto__, typename T0__, typename T2__, typename T3__,
typename T4__, typename T_lp__, typename T_lp_accum__>
stan::promote_args_t<T0__, T2__, T3__,
T4__>
operator()(const T0__& gamma, const int& dist, const T2__& mean,
           const T3__& scale, const T4__& df, T_lp__& lp__,
           T_lp_accum__& lp_accum__, std::ostream* pstream__)  const 
{
return gamma_lp<propto__>(gamma, dist, mean, scale, df, lp__, lp_accum__,
         pstream__);
}
};
#include <stan_meta_header.hpp>
class model_survextrap final : public model_base_crtp<model_survextrap> {
private:
  int nevent;
  int nrcens;
  int nvars;
  int nextern;
  int ncovs;
  int ncurecovs;
  double log_crude_event_rate;
  Eigen::Matrix<double, -1, -1> basis_event;
  Eigen::Matrix<double, -1, -1> ibasis_event;
  Eigen::Matrix<double, -1, -1> ibasis_rcens;
  Eigen::Matrix<double, -1, -1> ibasis_ext_stop;
  Eigen::Matrix<double, -1, -1> ibasis_ext_start;
  Eigen::Matrix<double, -1, -1> x_event;
  Eigen::Matrix<double, -1, -1> x_rcens;
  Eigen::Matrix<double, -1, -1> xcure_event;
  Eigen::Matrix<double, -1, -1> xcure_rcens;
  std::vector<int> r_ext;
  std::vector<int> n_ext;
  Eigen::Matrix<double, -1, -1> x_ext;
  Eigen::Matrix<double, -1, -1> xcure_ext;
  Eigen::Matrix<double, -1, 1> beta_mean;
  int est_smooth;
  Eigen::Matrix<double, -1, 1> smooth_sd_fixed;
  int cure;
  Eigen::Matrix<double, -1, 1> cure_shape;
  int modelid;
  int beta_err_1dim__;
 
public:
  ~model_survextrap() { }
  
  inline std::string model_name() const final { return "model_survextrap"; }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = stanc3 v2.26.1-1-g67504470", "stancflags = "};
  }
  
  
  model_survextrap(stan::io::var_context& context__,
                   unsigned int random_seed__ = 0,
                   std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "model_survextrap_namespace::model_survextrap";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      current_statement__ = 97;
      context__.validate_dims("data initialization","nevent","int",
          context__.to_vec());
      nevent = std::numeric_limits<int>::min();
      
      current_statement__ = 97;
      nevent = context__.vals_i("nevent")[(1 - 1)];
      current_statement__ = 97;
      current_statement__ = 97;
      check_greater_or_equal(function__, "nevent", nevent, 0);
      current_statement__ = 98;
      context__.validate_dims("data initialization","nrcens","int",
          context__.to_vec());
      nrcens = std::numeric_limits<int>::min();
      
      current_statement__ = 98;
      nrcens = context__.vals_i("nrcens")[(1 - 1)];
      current_statement__ = 98;
      current_statement__ = 98;
      check_greater_or_equal(function__, "nrcens", nrcens, 0);
      current_statement__ = 99;
      context__.validate_dims("data initialization","nvars","int",
          context__.to_vec());
      nvars = std::numeric_limits<int>::min();
      
      current_statement__ = 99;
      nvars = context__.vals_i("nvars")[(1 - 1)];
      current_statement__ = 99;
      current_statement__ = 99;
      check_greater_or_equal(function__, "nvars", nvars, 0);
      current_statement__ = 100;
      context__.validate_dims("data initialization","nextern","int",
          context__.to_vec());
      nextern = std::numeric_limits<int>::min();
      
      current_statement__ = 100;
      nextern = context__.vals_i("nextern")[(1 - 1)];
      current_statement__ = 100;
      current_statement__ = 100;
      check_greater_or_equal(function__, "nextern", nextern, 0);
      current_statement__ = 101;
      context__.validate_dims("data initialization","ncovs","int",
          context__.to_vec());
      ncovs = std::numeric_limits<int>::min();
      
      current_statement__ = 101;
      ncovs = context__.vals_i("ncovs")[(1 - 1)];
      current_statement__ = 101;
      current_statement__ = 101;
      check_greater_or_equal(function__, "ncovs", ncovs, 0);
      current_statement__ = 102;
      context__.validate_dims("data initialization","ncurecovs","int",
          context__.to_vec());
      ncurecovs = std::numeric_limits<int>::min();
      
      current_statement__ = 102;
      ncurecovs = context__.vals_i("ncurecovs")[(1 - 1)];
      current_statement__ = 102;
      current_statement__ = 102;
      check_greater_or_equal(function__, "ncurecovs", ncurecovs, 0);
      current_statement__ = 103;
      context__.validate_dims("data initialization","log_crude_event_rate",
          "double",context__.to_vec());
      log_crude_event_rate = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 103;
      log_crude_event_rate = context__.vals_r("log_crude_event_rate")[
          (1 - 1)];
      current_statement__ = 104;
      validate_non_negative_index("basis_event", "nevent", nevent);
      current_statement__ = 105;
      validate_non_negative_index("basis_event", "nvars", nvars);
      current_statement__ = 106;
      context__.validate_dims("data initialization","basis_event","double",
          context__.to_vec(nevent, nvars));
      basis_event = Eigen::Matrix<double, -1, -1>(nevent, nvars);
      stan::math::fill(basis_event, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> basis_event_flat__;
        current_statement__ = 106;
        assign(basis_event_flat__, nil_index_list(),
          context__.vals_r("basis_event"),
          "assigning variable basis_event_flat__");
        current_statement__ = 106;
        pos__ = 1;
        current_statement__ = 106;
        for (int sym1__ = 1; sym1__ <= nvars; ++sym1__) {
          current_statement__ = 106;
          for (int sym2__ = 1; sym2__ <= nevent; ++sym2__) {
            current_statement__ = 106;
            assign(basis_event,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              basis_event_flat__[(pos__ - 1)],
              "assigning variable basis_event");
            current_statement__ = 106;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 107;
      validate_non_negative_index("ibasis_event", "nevent", nevent);
      current_statement__ = 108;
      validate_non_negative_index("ibasis_event", "nvars", nvars);
      current_statement__ = 109;
      context__.validate_dims("data initialization","ibasis_event","double",
          context__.to_vec(nevent, nvars));
      ibasis_event = Eigen::Matrix<double, -1, -1>(nevent, nvars);
      stan::math::fill(ibasis_event, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> ibasis_event_flat__;
        current_statement__ = 109;
        assign(ibasis_event_flat__, nil_index_list(),
          context__.vals_r("ibasis_event"),
          "assigning variable ibasis_event_flat__");
        current_statement__ = 109;
        pos__ = 1;
        current_statement__ = 109;
        for (int sym1__ = 1; sym1__ <= nvars; ++sym1__) {
          current_statement__ = 109;
          for (int sym2__ = 1; sym2__ <= nevent; ++sym2__) {
            current_statement__ = 109;
            assign(ibasis_event,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              ibasis_event_flat__[(pos__ - 1)],
              "assigning variable ibasis_event");
            current_statement__ = 109;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 110;
      validate_non_negative_index("ibasis_rcens", "nrcens", nrcens);
      current_statement__ = 111;
      validate_non_negative_index("ibasis_rcens", "nvars", nvars);
      current_statement__ = 112;
      context__.validate_dims("data initialization","ibasis_rcens","double",
          context__.to_vec(nrcens, nvars));
      ibasis_rcens = Eigen::Matrix<double, -1, -1>(nrcens, nvars);
      stan::math::fill(ibasis_rcens, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> ibasis_rcens_flat__;
        current_statement__ = 112;
        assign(ibasis_rcens_flat__, nil_index_list(),
          context__.vals_r("ibasis_rcens"),
          "assigning variable ibasis_rcens_flat__");
        current_statement__ = 112;
        pos__ = 1;
        current_statement__ = 112;
        for (int sym1__ = 1; sym1__ <= nvars; ++sym1__) {
          current_statement__ = 112;
          for (int sym2__ = 1; sym2__ <= nrcens; ++sym2__) {
            current_statement__ = 112;
            assign(ibasis_rcens,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              ibasis_rcens_flat__[(pos__ - 1)],
              "assigning variable ibasis_rcens");
            current_statement__ = 112;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 113;
      validate_non_negative_index("ibasis_ext_stop", "nextern", nextern);
      current_statement__ = 114;
      validate_non_negative_index("ibasis_ext_stop", "nvars", nvars);
      current_statement__ = 115;
      context__.validate_dims("data initialization","ibasis_ext_stop",
          "double",context__.to_vec(nextern, nvars));
      ibasis_ext_stop = Eigen::Matrix<double, -1, -1>(nextern, nvars);
      stan::math::fill(ibasis_ext_stop, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> ibasis_ext_stop_flat__;
        current_statement__ = 115;
        assign(ibasis_ext_stop_flat__, nil_index_list(),
          context__.vals_r("ibasis_ext_stop"),
          "assigning variable ibasis_ext_stop_flat__");
        current_statement__ = 115;
        pos__ = 1;
        current_statement__ = 115;
        for (int sym1__ = 1; sym1__ <= nvars; ++sym1__) {
          current_statement__ = 115;
          for (int sym2__ = 1; sym2__ <= nextern; ++sym2__) {
            current_statement__ = 115;
            assign(ibasis_ext_stop,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              ibasis_ext_stop_flat__[(pos__ - 1)],
              "assigning variable ibasis_ext_stop");
            current_statement__ = 115;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 116;
      validate_non_negative_index("ibasis_ext_start", "nextern", nextern);
      current_statement__ = 117;
      validate_non_negative_index("ibasis_ext_start", "nvars", nvars);
      current_statement__ = 118;
      context__.validate_dims("data initialization","ibasis_ext_start",
          "double",context__.to_vec(nextern, nvars));
      ibasis_ext_start = Eigen::Matrix<double, -1, -1>(nextern, nvars);
      stan::math::fill(ibasis_ext_start, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> ibasis_ext_start_flat__;
        current_statement__ = 118;
        assign(ibasis_ext_start_flat__, nil_index_list(),
          context__.vals_r("ibasis_ext_start"),
          "assigning variable ibasis_ext_start_flat__");
        current_statement__ = 118;
        pos__ = 1;
        current_statement__ = 118;
        for (int sym1__ = 1; sym1__ <= nvars; ++sym1__) {
          current_statement__ = 118;
          for (int sym2__ = 1; sym2__ <= nextern; ++sym2__) {
            current_statement__ = 118;
            assign(ibasis_ext_start,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              ibasis_ext_start_flat__[(pos__ - 1)],
              "assigning variable ibasis_ext_start");
            current_statement__ = 118;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 119;
      validate_non_negative_index("x_event", "nevent", nevent);
      current_statement__ = 120;
      validate_non_negative_index("x_event", "ncovs", ncovs);
      current_statement__ = 121;
      context__.validate_dims("data initialization","x_event","double",
          context__.to_vec(nevent, ncovs));
      x_event = Eigen::Matrix<double, -1, -1>(nevent, ncovs);
      stan::math::fill(x_event, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> x_event_flat__;
        current_statement__ = 121;
        assign(x_event_flat__, nil_index_list(), context__.vals_r("x_event"),
          "assigning variable x_event_flat__");
        current_statement__ = 121;
        pos__ = 1;
        current_statement__ = 121;
        for (int sym1__ = 1; sym1__ <= ncovs; ++sym1__) {
          current_statement__ = 121;
          for (int sym2__ = 1; sym2__ <= nevent; ++sym2__) {
            current_statement__ = 121;
            assign(x_event,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              x_event_flat__[(pos__ - 1)], "assigning variable x_event");
            current_statement__ = 121;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 122;
      validate_non_negative_index("x_rcens", "nrcens", nrcens);
      current_statement__ = 123;
      validate_non_negative_index("x_rcens", "ncovs", ncovs);
      current_statement__ = 124;
      context__.validate_dims("data initialization","x_rcens","double",
          context__.to_vec(nrcens, ncovs));
      x_rcens = Eigen::Matrix<double, -1, -1>(nrcens, ncovs);
      stan::math::fill(x_rcens, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> x_rcens_flat__;
        current_statement__ = 124;
        assign(x_rcens_flat__, nil_index_list(), context__.vals_r("x_rcens"),
          "assigning variable x_rcens_flat__");
        current_statement__ = 124;
        pos__ = 1;
        current_statement__ = 124;
        for (int sym1__ = 1; sym1__ <= ncovs; ++sym1__) {
          current_statement__ = 124;
          for (int sym2__ = 1; sym2__ <= nrcens; ++sym2__) {
            current_statement__ = 124;
            assign(x_rcens,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              x_rcens_flat__[(pos__ - 1)], "assigning variable x_rcens");
            current_statement__ = 124;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 125;
      validate_non_negative_index("xcure_event", "nevent", nevent);
      current_statement__ = 126;
      validate_non_negative_index("xcure_event", "ncurecovs", ncurecovs);
      current_statement__ = 127;
      context__.validate_dims("data initialization","xcure_event","double",
          context__.to_vec(nevent, ncurecovs));
      xcure_event = Eigen::Matrix<double, -1, -1>(nevent, ncurecovs);
      stan::math::fill(xcure_event, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> xcure_event_flat__;
        current_statement__ = 127;
        assign(xcure_event_flat__, nil_index_list(),
          context__.vals_r("xcure_event"),
          "assigning variable xcure_event_flat__");
        current_statement__ = 127;
        pos__ = 1;
        current_statement__ = 127;
        for (int sym1__ = 1; sym1__ <= ncurecovs; ++sym1__) {
          current_statement__ = 127;
          for (int sym2__ = 1; sym2__ <= nevent; ++sym2__) {
            current_statement__ = 127;
            assign(xcure_event,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              xcure_event_flat__[(pos__ - 1)],
              "assigning variable xcure_event");
            current_statement__ = 127;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 128;
      validate_non_negative_index("xcure_rcens", "nrcens", nrcens);
      current_statement__ = 129;
      validate_non_negative_index("xcure_rcens", "ncurecovs", ncurecovs);
      current_statement__ = 130;
      context__.validate_dims("data initialization","xcure_rcens","double",
          context__.to_vec(nrcens, ncurecovs));
      xcure_rcens = Eigen::Matrix<double, -1, -1>(nrcens, ncurecovs);
      stan::math::fill(xcure_rcens, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> xcure_rcens_flat__;
        current_statement__ = 130;
        assign(xcure_rcens_flat__, nil_index_list(),
          context__.vals_r("xcure_rcens"),
          "assigning variable xcure_rcens_flat__");
        current_statement__ = 130;
        pos__ = 1;
        current_statement__ = 130;
        for (int sym1__ = 1; sym1__ <= ncurecovs; ++sym1__) {
          current_statement__ = 130;
          for (int sym2__ = 1; sym2__ <= nrcens; ++sym2__) {
            current_statement__ = 130;
            assign(xcure_rcens,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              xcure_rcens_flat__[(pos__ - 1)],
              "assigning variable xcure_rcens");
            current_statement__ = 130;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 131;
      validate_non_negative_index("r_ext", "nextern", nextern);
      current_statement__ = 132;
      context__.validate_dims("data initialization","r_ext","int",
          context__.to_vec(nextern));
      r_ext = std::vector<int>(nextern, std::numeric_limits<int>::min());
      
      current_statement__ = 132;
      assign(r_ext, nil_index_list(), context__.vals_i("r_ext"),
        "assigning variable r_ext");
      current_statement__ = 132;
      for (int sym1__ = 1; sym1__ <= nextern; ++sym1__) {
        current_statement__ = 132;
        current_statement__ = 132;
        check_greater_or_equal(function__, "r_ext[sym1__]",
                               r_ext[(sym1__ - 1)], 0);}
      current_statement__ = 133;
      validate_non_negative_index("n_ext", "nextern", nextern);
      current_statement__ = 134;
      context__.validate_dims("data initialization","n_ext","int",
          context__.to_vec(nextern));
      n_ext = std::vector<int>(nextern, std::numeric_limits<int>::min());
      
      current_statement__ = 134;
      assign(n_ext, nil_index_list(), context__.vals_i("n_ext"),
        "assigning variable n_ext");
      current_statement__ = 134;
      for (int sym1__ = 1; sym1__ <= nextern; ++sym1__) {
        current_statement__ = 134;
        current_statement__ = 134;
        check_greater_or_equal(function__, "n_ext[sym1__]",
                               n_ext[(sym1__ - 1)], 0);}
      current_statement__ = 135;
      validate_non_negative_index("x_ext", "nextern", nextern);
      current_statement__ = 136;
      validate_non_negative_index("x_ext", "ncovs", ncovs);
      current_statement__ = 137;
      context__.validate_dims("data initialization","x_ext","double",
          context__.to_vec(nextern, ncovs));
      x_ext = Eigen::Matrix<double, -1, -1>(nextern, ncovs);
      stan::math::fill(x_ext, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> x_ext_flat__;
        current_statement__ = 137;
        assign(x_ext_flat__, nil_index_list(), context__.vals_r("x_ext"),
          "assigning variable x_ext_flat__");
        current_statement__ = 137;
        pos__ = 1;
        current_statement__ = 137;
        for (int sym1__ = 1; sym1__ <= ncovs; ++sym1__) {
          current_statement__ = 137;
          for (int sym2__ = 1; sym2__ <= nextern; ++sym2__) {
            current_statement__ = 137;
            assign(x_ext,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              x_ext_flat__[(pos__ - 1)], "assigning variable x_ext");
            current_statement__ = 137;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 138;
      validate_non_negative_index("xcure_ext", "nextern", nextern);
      current_statement__ = 139;
      validate_non_negative_index("xcure_ext", "ncurecovs", ncurecovs);
      current_statement__ = 140;
      context__.validate_dims("data initialization","xcure_ext","double",
          context__.to_vec(nextern, ncurecovs));
      xcure_ext = Eigen::Matrix<double, -1, -1>(nextern, ncurecovs);
      stan::math::fill(xcure_ext, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> xcure_ext_flat__;
        current_statement__ = 140;
        assign(xcure_ext_flat__, nil_index_list(),
          context__.vals_r("xcure_ext"),
          "assigning variable xcure_ext_flat__");
        current_statement__ = 140;
        pos__ = 1;
        current_statement__ = 140;
        for (int sym1__ = 1; sym1__ <= ncurecovs; ++sym1__) {
          current_statement__ = 140;
          for (int sym2__ = 1; sym2__ <= nextern; ++sym2__) {
            current_statement__ = 140;
            assign(xcure_ext,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              xcure_ext_flat__[(pos__ - 1)], "assigning variable xcure_ext");
            current_statement__ = 140;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 141;
      validate_non_negative_index("beta_mean", "nvars - 1", (nvars - 1));
      current_statement__ = 142;
      context__.validate_dims("data initialization","beta_mean","double",
          context__.to_vec((nvars - 1)));
      beta_mean = Eigen::Matrix<double, -1, 1>((nvars - 1));
      stan::math::fill(beta_mean, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> beta_mean_flat__;
        current_statement__ = 142;
        assign(beta_mean_flat__, nil_index_list(),
          context__.vals_r("beta_mean"),
          "assigning variable beta_mean_flat__");
        current_statement__ = 142;
        pos__ = 1;
        current_statement__ = 142;
        for (int sym1__ = 1; sym1__ <= (nvars - 1); ++sym1__) {
          current_statement__ = 142;
          assign(beta_mean, cons_list(index_uni(sym1__), nil_index_list()),
            beta_mean_flat__[(pos__ - 1)], "assigning variable beta_mean");
          current_statement__ = 142;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 143;
      context__.validate_dims("data initialization","est_smooth","int",
          context__.to_vec());
      est_smooth = std::numeric_limits<int>::min();
      
      current_statement__ = 143;
      est_smooth = context__.vals_i("est_smooth")[(1 - 1)];
      current_statement__ = 144;
      validate_non_negative_index("smooth_sd_fixed", "1 - est_smooth",
                                  (1 - est_smooth));
      current_statement__ = 145;
      context__.validate_dims("data initialization","smooth_sd_fixed",
          "double",context__.to_vec((1 - est_smooth)));
      smooth_sd_fixed = Eigen::Matrix<double, -1, 1>((1 - est_smooth));
      stan::math::fill(smooth_sd_fixed, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> smooth_sd_fixed_flat__;
        current_statement__ = 145;
        assign(smooth_sd_fixed_flat__, nil_index_list(),
          context__.vals_r("smooth_sd_fixed"),
          "assigning variable smooth_sd_fixed_flat__");
        current_statement__ = 145;
        pos__ = 1;
        current_statement__ = 145;
        for (int sym1__ = 1; sym1__ <= (1 - est_smooth); ++sym1__) {
          current_statement__ = 145;
          assign(smooth_sd_fixed,
            cons_list(index_uni(sym1__), nil_index_list()),
            smooth_sd_fixed_flat__[(pos__ - 1)],
            "assigning variable smooth_sd_fixed");
          current_statement__ = 145;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 145;
      for (int sym1__ = 1; sym1__ <= (1 - est_smooth); ++sym1__) {
        current_statement__ = 145;
        current_statement__ = 145;
        check_greater_or_equal(function__, "smooth_sd_fixed[sym1__]",
                               smooth_sd_fixed[(sym1__ - 1)], 0);}
      current_statement__ = 146;
      context__.validate_dims("data initialization","cure","int",
          context__.to_vec());
      cure = std::numeric_limits<int>::min();
      
      current_statement__ = 146;
      cure = context__.vals_i("cure")[(1 - 1)];
      current_statement__ = 147;
      context__.validate_dims("data initialization","cure_shape","double",
          context__.to_vec(2));
      cure_shape = Eigen::Matrix<double, -1, 1>(2);
      stan::math::fill(cure_shape, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> cure_shape_flat__;
        current_statement__ = 147;
        assign(cure_shape_flat__, nil_index_list(),
          context__.vals_r("cure_shape"),
          "assigning variable cure_shape_flat__");
        current_statement__ = 147;
        pos__ = 1;
        current_statement__ = 147;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 147;
          assign(cure_shape, cons_list(index_uni(sym1__), nil_index_list()),
            cure_shape_flat__[(pos__ - 1)], "assigning variable cure_shape");
          current_statement__ = 147;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 147;
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        current_statement__ = 147;
        current_statement__ = 147;
        check_greater_or_equal(function__, "cure_shape[sym1__]",
                               cure_shape[(sym1__ - 1)], 0);}
      current_statement__ = 148;
      context__.validate_dims("data initialization","modelid","int",
          context__.to_vec());
      modelid = std::numeric_limits<int>::min();
      
      current_statement__ = 148;
      modelid = context__.vals_i("modelid")[(1 - 1)];
      current_statement__ = 149;
      validate_non_negative_index("gamma", "1", 1);
      current_statement__ = 150;
      validate_non_negative_index("loghr", "ncovs", ncovs);
      current_statement__ = 151;
      beta_err_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 151;
      beta_err_1dim__ = (nvars - 1);
      current_statement__ = 151;
      validate_non_negative_index("beta_err", "nvars - 1", beta_err_1dim__);
      current_statement__ = 152;
      validate_non_negative_index("smooth_sd", "est_smooth", est_smooth);
      current_statement__ = 153;
      validate_non_negative_index("pcure", "cure", cure);
      current_statement__ = 154;
      validate_non_negative_index("logor_cure", "ncurecovs", ncurecovs);
      current_statement__ = 155;
      validate_non_negative_index("beta", "nvars", nvars);
      current_statement__ = 156;
      validate_non_negative_index("coefs", "nvars", nvars);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += 1;
      num_params_r__ += ncovs;
      num_params_r__ += beta_err_1dim__;
      num_params_r__ += est_smooth;
      num_params_r__ += cure;
      num_params_r__ += ncurecovs;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename VecR, typename VecI, stan::require_vector_like_t<VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "model_survextrap_namespace::log_prob";
(void) function__;  // suppress unused var warning
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      std::vector<local_scalar_t__> gamma;
      gamma = std::vector<local_scalar_t__>(1, DUMMY_VAR__);
      
      current_statement__ = 1;
      for (int sym1__ = 1; sym1__ <= 1; ++sym1__) {
        current_statement__ = 1;
        assign(gamma, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable gamma");}
      Eigen::Matrix<local_scalar_t__, -1, 1> loghr;
      loghr = Eigen::Matrix<local_scalar_t__, -1, 1>(ncovs);
      stan::math::fill(loghr, DUMMY_VAR__);
      
      current_statement__ = 2;
      loghr = in__.vector(ncovs);
      Eigen::Matrix<local_scalar_t__, -1, 1> beta_err;
      beta_err = Eigen::Matrix<local_scalar_t__, -1, 1>(beta_err_1dim__);
      stan::math::fill(beta_err, DUMMY_VAR__);
      
      current_statement__ = 3;
      beta_err = in__.vector(beta_err_1dim__);
      Eigen::Matrix<local_scalar_t__, -1, 1> smooth_sd;
      smooth_sd = Eigen::Matrix<local_scalar_t__, -1, 1>(est_smooth);
      stan::math::fill(smooth_sd, DUMMY_VAR__);
      
      current_statement__ = 4;
      smooth_sd = in__.vector(est_smooth);
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= est_smooth; ++sym1__) {
        current_statement__ = 4;
        if (jacobian__) {
          current_statement__ = 4;
          assign(smooth_sd, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(smooth_sd[(sym1__ - 1)], 0, lp__),
            "assigning variable smooth_sd");
        } else {
          current_statement__ = 4;
          assign(smooth_sd, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(smooth_sd[(sym1__ - 1)], 0),
            "assigning variable smooth_sd");
        }}
      Eigen::Matrix<local_scalar_t__, -1, 1> pcure;
      pcure = Eigen::Matrix<local_scalar_t__, -1, 1>(cure);
      stan::math::fill(pcure, DUMMY_VAR__);
      
      current_statement__ = 5;
      pcure = in__.vector(cure);
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= cure; ++sym1__) {
        current_statement__ = 5;
        if (jacobian__) {
          current_statement__ = 5;
          assign(pcure, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lub_constrain(pcure[(sym1__ - 1)], 0, 1, lp__),
            "assigning variable pcure");
        } else {
          current_statement__ = 5;
          assign(pcure, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lub_constrain(pcure[(sym1__ - 1)], 0, 1),
            "assigning variable pcure");
        }}
      Eigen::Matrix<local_scalar_t__, -1, 1> logor_cure;
      logor_cure = Eigen::Matrix<local_scalar_t__, -1, 1>(ncurecovs);
      stan::math::fill(logor_cure, DUMMY_VAR__);
      
      current_statement__ = 6;
      logor_cure = in__.vector(ncurecovs);
      Eigen::Matrix<local_scalar_t__, -1, 1> beta;
      beta = Eigen::Matrix<local_scalar_t__, -1, 1>(nvars);
      stan::math::fill(beta, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, 1> coefs;
      coefs = Eigen::Matrix<local_scalar_t__, -1, 1>(nvars);
      stan::math::fill(coefs, DUMMY_VAR__);
      
      current_statement__ = 11;
      if (est_smooth) {
        current_statement__ = 10;
        assign(beta, nil_index_list(),
          append_row(0,
            add(beta_mean, multiply(beta_err, smooth_sd[(1 - 1)]))),
          "assigning variable beta");
      } else {
        current_statement__ = 9;
        assign(beta, nil_index_list(),
          append_row(0,
            add(beta_mean, multiply(beta_err, smooth_sd_fixed[(1 - 1)]))),
          "assigning variable beta");
      }
      current_statement__ = 17;
      if (logical_eq(modelid, 1)) {
        current_statement__ = 15;
        assign(coefs, nil_index_list(), softmax(beta),
          "assigning variable coefs");
      } else {
        current_statement__ = 12;
        assign(coefs, cons_list(index_uni(1), nil_index_list()),
          stan::math::exp(beta_err[(1 - 1)]), "assigning variable coefs");
        current_statement__ = 13;
        assign(coefs, cons_list(index_uni(2), nil_index_list()), 0,
          "assigning variable coefs");
      }
      {
        current_statement__ = 19;
        validate_non_negative_index("eta_event", "nevent", nevent);
        Eigen::Matrix<local_scalar_t__, -1, 1> eta_event;
        eta_event = Eigen::Matrix<local_scalar_t__, -1, 1>(nevent);
        stan::math::fill(eta_event, DUMMY_VAR__);
        
        current_statement__ = 21;
        validate_non_negative_index("eta_rcens", "nrcens", nrcens);
        Eigen::Matrix<local_scalar_t__, -1, 1> eta_rcens;
        eta_rcens = Eigen::Matrix<local_scalar_t__, -1, 1>(nrcens);
        stan::math::fill(eta_rcens, DUMMY_VAR__);
        
        current_statement__ = 23;
        validate_non_negative_index("eta_extern", "nextern", nextern);
        Eigen::Matrix<local_scalar_t__, -1, 1> eta_extern;
        eta_extern = Eigen::Matrix<local_scalar_t__, -1, 1>(nextern);
        stan::math::fill(eta_extern, DUMMY_VAR__);
        
        local_scalar_t__ dummy;
        dummy = DUMMY_VAR__;
        
        local_scalar_t__ cp;
        cp = DUMMY_VAR__;
        
        current_statement__ = 27;
        validate_non_negative_index("p_ext_stop", "nextern", nextern);
        Eigen::Matrix<local_scalar_t__, -1, 1> p_ext_stop;
        p_ext_stop = Eigen::Matrix<local_scalar_t__, -1, 1>(nextern);
        stan::math::fill(p_ext_stop, DUMMY_VAR__);
        
        current_statement__ = 29;
        validate_non_negative_index("p_ext_start", "nextern", nextern);
        Eigen::Matrix<local_scalar_t__, -1, 1> p_ext_start;
        p_ext_start = Eigen::Matrix<local_scalar_t__, -1, 1>(nextern);
        stan::math::fill(p_ext_start, DUMMY_VAR__);
        
        current_statement__ = 31;
        validate_non_negative_index("pcure_event", "nevent", nevent);
        Eigen::Matrix<local_scalar_t__, -1, 1> pcure_event;
        pcure_event = Eigen::Matrix<local_scalar_t__, -1, 1>(nevent);
        stan::math::fill(pcure_event, DUMMY_VAR__);
        
        current_statement__ = 33;
        validate_non_negative_index("pcure_rcens", "nrcens", nrcens);
        Eigen::Matrix<local_scalar_t__, -1, 1> pcure_rcens;
        pcure_rcens = Eigen::Matrix<local_scalar_t__, -1, 1>(nrcens);
        stan::math::fill(pcure_rcens, DUMMY_VAR__);
        
        current_statement__ = 35;
        validate_non_negative_index("pcure_extern", "nextern", nextern);
        Eigen::Matrix<local_scalar_t__, -1, 1> pcure_extern;
        pcure_extern = Eigen::Matrix<local_scalar_t__, -1, 1>(nextern);
        stan::math::fill(pcure_extern, DUMMY_VAR__);
        
        current_statement__ = 51;
        if (logical_gt(ncovs, 0)) {
          current_statement__ = 45;
          if (logical_gt(nevent, 0)) {
            current_statement__ = 44;
            assign(eta_event, nil_index_list(), multiply(x_event, loghr),
              "assigning variable eta_event");
          } 
          current_statement__ = 47;
          if (logical_gt(nrcens, 0)) {
            current_statement__ = 46;
            assign(eta_rcens, nil_index_list(), multiply(x_rcens, loghr),
              "assigning variable eta_rcens");
          } 
          current_statement__ = 49;
          if (logical_gt(nextern, 0)) {
            current_statement__ = 48;
            assign(eta_extern, nil_index_list(), multiply(x_ext, loghr),
              "assigning variable eta_extern");
          } 
        } else {
          current_statement__ = 38;
          if (logical_gt(nevent, 0)) {
            current_statement__ = 37;
            assign(eta_event, nil_index_list(), rep_vector(0.0, nevent),
              "assigning variable eta_event");
          } 
          current_statement__ = 40;
          if (logical_gt(nrcens, 0)) {
            current_statement__ = 39;
            assign(eta_rcens, nil_index_list(), rep_vector(0.0, nrcens),
              "assigning variable eta_rcens");
          } 
          current_statement__ = 42;
          if (logical_gt(nextern, 0)) {
            current_statement__ = 41;
            assign(eta_extern, nil_index_list(), rep_vector(0.0, nextern),
              "assigning variable eta_extern");
          } 
        }
        current_statement__ = 53;
        if (logical_gt(nevent, 0)) {
          current_statement__ = 52;
          assign(eta_event, nil_index_list(),
            add(stan::model::deep_copy(eta_event), log_crude_event_rate),
            "assigning variable eta_event");
        } 
        current_statement__ = 55;
        if (logical_gt(nrcens, 0)) {
          current_statement__ = 54;
          assign(eta_rcens, nil_index_list(),
            add(stan::model::deep_copy(eta_rcens), log_crude_event_rate),
            "assigning variable eta_rcens");
        } 
        current_statement__ = 57;
        if (logical_gt(nextern, 0)) {
          current_statement__ = 56;
          assign(eta_extern, nil_index_list(),
            add(stan::model::deep_copy(eta_extern), log_crude_event_rate),
            "assigning variable eta_extern");
        } 
        current_statement__ = 59;
        if (logical_gt(nevent, 0)) {
          current_statement__ = 58;
          assign(eta_event, nil_index_list(),
            add(stan::model::deep_copy(eta_event), gamma[(1 - 1)]),
            "assigning variable eta_event");
        } 
        current_statement__ = 61;
        if (logical_gt(nrcens, 0)) {
          current_statement__ = 60;
          assign(eta_rcens, nil_index_list(),
            add(stan::model::deep_copy(eta_rcens), gamma[(1 - 1)]),
            "assigning variable eta_rcens");
        } 
        current_statement__ = 63;
        if (logical_gt(nextern, 0)) {
          current_statement__ = 62;
          assign(eta_extern, nil_index_list(),
            add(stan::model::deep_copy(eta_extern), gamma[(1 - 1)]),
            "assigning variable eta_extern");
        } 
        current_statement__ = 66;
        if (cure) {
          current_statement__ = 65;
          cp = pcure[(1 - 1)];
        } else {
          current_statement__ = 64;
          cp = 0;
        }
        current_statement__ = 67;
        assign(pcure_event, nil_index_list(), rep_vector(cp, nevent),
          "assigning variable pcure_event");
        current_statement__ = 68;
        assign(pcure_rcens, nil_index_list(), rep_vector(cp, nrcens),
          "assigning variable pcure_rcens");
        current_statement__ = 69;
        assign(pcure_extern, nil_index_list(), rep_vector(cp, nextern),
          "assigning variable pcure_extern");
        current_statement__ = 77;
        if (logical_gt(ncurecovs, 0)) {
          current_statement__ = 71;
          if (logical_gt(nevent, 0)) {
            current_statement__ = 70;
            assign(pcure_event, nil_index_list(),
              inv_logit(
                add(logit(stan::model::deep_copy(pcure_event)),
                  multiply(xcure_event, logor_cure))),
              "assigning variable pcure_event");
          } 
          current_statement__ = 73;
          if (logical_gt(nrcens, 0)) {
            current_statement__ = 72;
            assign(pcure_rcens, nil_index_list(),
              inv_logit(
                add(logit(stan::model::deep_copy(pcure_rcens)),
                  multiply(xcure_rcens, logor_cure))),
              "assigning variable pcure_rcens");
          } 
          current_statement__ = 75;
          if (logical_gt(nextern, 0)) {
            current_statement__ = 74;
            assign(pcure_extern, nil_index_list(),
              inv_logit(
                add(logit(stan::model::deep_copy(pcure_extern)),
                  multiply(xcure_ext, logor_cure))),
              "assigning variable pcure_extern");
          } 
        } 
        current_statement__ = 79;
        if (logical_gt(nevent, 0)) {
          current_statement__ = 78;
          lp_accum__.add(
            log_dens(eta_event, basis_event, coefs, cure, pcure_event,
              ibasis_event, modelid, pstream__));
        } 
        current_statement__ = 81;
        if (logical_gt(nrcens, 0)) {
          current_statement__ = 80;
          lp_accum__.add(
            log_surv(eta_rcens, ibasis_rcens, coefs, cure, pcure_rcens,
              modelid, pstream__));
        } 
        current_statement__ = 86;
        if (logical_gt(nextern, 0)) {
          current_statement__ = 82;
          assign(p_ext_stop, nil_index_list(),
            stan::math::exp(
              log_surv(eta_extern, ibasis_ext_stop, coefs, cure,
                pcure_extern, modelid, pstream__)),
            "assigning variable p_ext_stop");
          current_statement__ = 83;
          assign(p_ext_start, nil_index_list(),
            stan::math::exp(
              log_surv(eta_extern, ibasis_ext_start, coefs, cure,
                pcure_extern, modelid, pstream__)),
            "assigning variable p_ext_start");
          current_statement__ = 84;
          lp_accum__.add(
            binomial_lpmf<false>(r_ext, n_ext,
              elt_divide(p_ext_stop, p_ext_start)));
        } 
        current_statement__ = 87;
        dummy = gamma_lp<false>(gamma[(1 - 1)], 1, 0, 20,
                  1, lp__, lp_accum__, pstream__);
        current_statement__ = 90;
        if (logical_eq(modelid, 1)) {
          current_statement__ = 88;
          lp_accum__.add(logistic_lpdf<propto__>(beta_err, 0, 1));
        } 
        current_statement__ = 93;
        if (cure) {
          current_statement__ = 91;
          lp_accum__.add(
            beta_lpdf<propto__>(pcure, cure_shape[(1 - 1)],
              cure_shape[(2 - 1)]));
        } 
        current_statement__ = 96;
        if (est_smooth) {
          current_statement__ = 94;
          lp_accum__.add(gamma_lpdf<propto__>(smooth_sd, 2, 1));
        } 
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr>
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "model_survextrap_namespace::write_array";
(void) function__;  // suppress unused var warning
    (void) function__;  // suppress unused var warning
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      std::vector<double> gamma;
      gamma = std::vector<double>(1, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 1;
      for (int sym1__ = 1; sym1__ <= 1; ++sym1__) {
        current_statement__ = 1;
        assign(gamma, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable gamma");}
      Eigen::Matrix<double, -1, 1> loghr;
      loghr = Eigen::Matrix<double, -1, 1>(ncovs);
      stan::math::fill(loghr, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 2;
      loghr = in__.vector(ncovs);
      Eigen::Matrix<double, -1, 1> beta_err;
      beta_err = Eigen::Matrix<double, -1, 1>(beta_err_1dim__);
      stan::math::fill(beta_err, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 3;
      beta_err = in__.vector(beta_err_1dim__);
      Eigen::Matrix<double, -1, 1> smooth_sd;
      smooth_sd = Eigen::Matrix<double, -1, 1>(est_smooth);
      stan::math::fill(smooth_sd, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 4;
      smooth_sd = in__.vector(est_smooth);
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= est_smooth; ++sym1__) {
        current_statement__ = 4;
        assign(smooth_sd, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_constrain(smooth_sd[(sym1__ - 1)], 0),
          "assigning variable smooth_sd");}
      Eigen::Matrix<double, -1, 1> pcure;
      pcure = Eigen::Matrix<double, -1, 1>(cure);
      stan::math::fill(pcure, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 5;
      pcure = in__.vector(cure);
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= cure; ++sym1__) {
        current_statement__ = 5;
        assign(pcure, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lub_constrain(pcure[(sym1__ - 1)], 0, 1),
          "assigning variable pcure");}
      Eigen::Matrix<double, -1, 1> logor_cure;
      logor_cure = Eigen::Matrix<double, -1, 1>(ncurecovs);
      stan::math::fill(logor_cure, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 6;
      logor_cure = in__.vector(ncurecovs);
      Eigen::Matrix<double, -1, 1> beta;
      beta = Eigen::Matrix<double, -1, 1>(nvars);
      stan::math::fill(beta, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> coefs;
      coefs = Eigen::Matrix<double, -1, 1>(nvars);
      stan::math::fill(coefs, std::numeric_limits<double>::quiet_NaN());
      
      for (int sym1__ = 1; sym1__ <= 1; ++sym1__) {
        vars__.emplace_back(gamma[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= ncovs; ++sym1__) {
        vars__.emplace_back(loghr[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= beta_err_1dim__; ++sym1__) {
        vars__.emplace_back(beta_err[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= est_smooth; ++sym1__) {
        vars__.emplace_back(smooth_sd[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= cure; ++sym1__) {
        vars__.emplace_back(pcure[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= ncurecovs; ++sym1__) {
        vars__.emplace_back(logor_cure[(sym1__ - 1)]);}
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 11;
      if (est_smooth) {
        current_statement__ = 10;
        assign(beta, nil_index_list(),
          append_row(0,
            add(beta_mean, multiply(beta_err, smooth_sd[(1 - 1)]))),
          "assigning variable beta");
      } else {
        current_statement__ = 9;
        assign(beta, nil_index_list(),
          append_row(0,
            add(beta_mean, multiply(beta_err, smooth_sd_fixed[(1 - 1)]))),
          "assigning variable beta");
      }
      current_statement__ = 17;
      if (logical_eq(modelid, 1)) {
        current_statement__ = 15;
        assign(coefs, nil_index_list(), softmax(beta),
          "assigning variable coefs");
      } else {
        current_statement__ = 12;
        assign(coefs, cons_list(index_uni(1), nil_index_list()),
          stan::math::exp(beta_err[(1 - 1)]), "assigning variable coefs");
        current_statement__ = 13;
        assign(coefs, cons_list(index_uni(2), nil_index_list()), 0,
          "assigning variable coefs");
      }
      if (emit_transformed_parameters__) {
        for (int sym1__ = 1; sym1__ <= nvars; ++sym1__) {
          vars__.emplace_back(beta[(sym1__ - 1)]);}
        for (int sym1__ = 1; sym1__ <= nvars; ++sym1__) {
          vars__.emplace_back(coefs[(sym1__ - 1)]);}
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      double alpha;
      alpha = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 18;
      alpha = (log_crude_event_rate + gamma[(1 - 1)]);
      vars__.emplace_back(alpha);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, stan::require_std_vector_t<VecVar>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void transform_inits_impl(const stan::io::var_context& context__,
                                   VecI& params_i__, VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      std::vector<double> gamma;
      gamma = std::vector<double>(1, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 1;
      assign(gamma, nil_index_list(), context__.vals_r("gamma"),
        "assigning variable gamma");
      Eigen::Matrix<double, -1, 1> loghr;
      loghr = Eigen::Matrix<double, -1, 1>(ncovs);
      stan::math::fill(loghr, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> loghr_flat__;
        current_statement__ = 2;
        assign(loghr_flat__, nil_index_list(), context__.vals_r("loghr"),
          "assigning variable loghr_flat__");
        current_statement__ = 2;
        pos__ = 1;
        current_statement__ = 2;
        for (int sym1__ = 1; sym1__ <= ncovs; ++sym1__) {
          current_statement__ = 2;
          assign(loghr, cons_list(index_uni(sym1__), nil_index_list()),
            loghr_flat__[(pos__ - 1)], "assigning variable loghr");
          current_statement__ = 2;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> beta_err;
      beta_err = Eigen::Matrix<double, -1, 1>(beta_err_1dim__);
      stan::math::fill(beta_err, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> beta_err_flat__;
        current_statement__ = 3;
        assign(beta_err_flat__, nil_index_list(),
          context__.vals_r("beta_err"), "assigning variable beta_err_flat__");
        current_statement__ = 3;
        pos__ = 1;
        current_statement__ = 3;
        for (int sym1__ = 1; sym1__ <= beta_err_1dim__; ++sym1__) {
          current_statement__ = 3;
          assign(beta_err, cons_list(index_uni(sym1__), nil_index_list()),
            beta_err_flat__[(pos__ - 1)], "assigning variable beta_err");
          current_statement__ = 3;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> smooth_sd;
      smooth_sd = Eigen::Matrix<double, -1, 1>(est_smooth);
      stan::math::fill(smooth_sd, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> smooth_sd_flat__;
        current_statement__ = 4;
        assign(smooth_sd_flat__, nil_index_list(),
          context__.vals_r("smooth_sd"),
          "assigning variable smooth_sd_flat__");
        current_statement__ = 4;
        pos__ = 1;
        current_statement__ = 4;
        for (int sym1__ = 1; sym1__ <= est_smooth; ++sym1__) {
          current_statement__ = 4;
          assign(smooth_sd, cons_list(index_uni(sym1__), nil_index_list()),
            smooth_sd_flat__[(pos__ - 1)], "assigning variable smooth_sd");
          current_statement__ = 4;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> smooth_sd_free__;
      smooth_sd_free__ = Eigen::Matrix<double, -1, 1>(est_smooth);
      stan::math::fill(smooth_sd_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= est_smooth; ++sym1__) {
        current_statement__ = 4;
        assign(smooth_sd_free__,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_free(smooth_sd[(sym1__ - 1)], 0),
          "assigning variable smooth_sd_free__");}
      Eigen::Matrix<double, -1, 1> pcure;
      pcure = Eigen::Matrix<double, -1, 1>(cure);
      stan::math::fill(pcure, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> pcure_flat__;
        current_statement__ = 5;
        assign(pcure_flat__, nil_index_list(), context__.vals_r("pcure"),
          "assigning variable pcure_flat__");
        current_statement__ = 5;
        pos__ = 1;
        current_statement__ = 5;
        for (int sym1__ = 1; sym1__ <= cure; ++sym1__) {
          current_statement__ = 5;
          assign(pcure, cons_list(index_uni(sym1__), nil_index_list()),
            pcure_flat__[(pos__ - 1)], "assigning variable pcure");
          current_statement__ = 5;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> pcure_free__;
      pcure_free__ = Eigen::Matrix<double, -1, 1>(cure);
      stan::math::fill(pcure_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= cure; ++sym1__) {
        current_statement__ = 5;
        assign(pcure_free__, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lub_free(pcure[(sym1__ - 1)], 0, 1),
          "assigning variable pcure_free__");}
      Eigen::Matrix<double, -1, 1> logor_cure;
      logor_cure = Eigen::Matrix<double, -1, 1>(ncurecovs);
      stan::math::fill(logor_cure, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> logor_cure_flat__;
        current_statement__ = 6;
        assign(logor_cure_flat__, nil_index_list(),
          context__.vals_r("logor_cure"),
          "assigning variable logor_cure_flat__");
        current_statement__ = 6;
        pos__ = 1;
        current_statement__ = 6;
        for (int sym1__ = 1; sym1__ <= ncurecovs; ++sym1__) {
          current_statement__ = 6;
          assign(logor_cure, cons_list(index_uni(sym1__), nil_index_list()),
            logor_cure_flat__[(pos__ - 1)], "assigning variable logor_cure");
          current_statement__ = 6;
          pos__ = (pos__ + 1);}
      }
      for (int sym1__ = 1; sym1__ <= 1; ++sym1__) {
        vars__.emplace_back(gamma[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= ncovs; ++sym1__) {
        vars__.emplace_back(loghr[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= beta_err_1dim__; ++sym1__) {
        vars__.emplace_back(beta_err[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= est_smooth; ++sym1__) {
        vars__.emplace_back(smooth_sd_free__[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= cure; ++sym1__) {
        vars__.emplace_back(pcure_free__[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= ncurecovs; ++sym1__) {
        vars__.emplace_back(logor_cure[(sym1__ - 1)]);}
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.clear();
    names__.emplace_back("gamma");
    names__.emplace_back("loghr");
    names__.emplace_back("beta_err");
    names__.emplace_back("smooth_sd");
    names__.emplace_back("pcure");
    names__.emplace_back("logor_cure");
    names__.emplace_back("beta");
    names__.emplace_back("coefs");
    names__.emplace_back("alpha");
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.clear();
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(1)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(ncovs)});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(beta_err_1dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(est_smooth)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(cure)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(ncurecovs)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nvars)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nvars)});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= 1; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "gamma" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= ncovs; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "loghr" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= beta_err_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "beta_err" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= est_smooth; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "smooth_sd" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= cure; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "pcure" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= ncurecovs; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "logor_cure" + '.' + std::to_string(sym1__));
      }}
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= nvars; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "beta" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nvars; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "coefs" + '.' + std::to_string(sym1__));
        }}
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "alpha");
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= 1; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "gamma" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= ncovs; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "loghr" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= beta_err_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "beta_err" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= est_smooth; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "smooth_sd" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= cure; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "pcure" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= ncurecovs; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "logor_cure" + '.' + std::to_string(sym1__));
      }}
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= nvars; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "beta" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nvars; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "coefs" + '.' + std::to_string(sym1__));
        }}
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "alpha");
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"gamma\",\"type\":{\"name\":\"array\",\"length\":" << 1 << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"loghr\",\"type\":{\"name\":\"vector\",\"length\":" << ncovs << "},\"block\":\"parameters\"},{\"name\":\"beta_err\",\"type\":{\"name\":\"vector\",\"length\":" << beta_err_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"smooth_sd\",\"type\":{\"name\":\"vector\",\"length\":" << est_smooth << "},\"block\":\"parameters\"},{\"name\":\"pcure\",\"type\":{\"name\":\"vector\",\"length\":" << cure << "},\"block\":\"parameters\"},{\"name\":\"logor_cure\",\"type\":{\"name\":\"vector\",\"length\":" << ncurecovs << "},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" << nvars << "},\"block\":\"transformed_parameters\"},{\"name\":\"coefs\",\"type\":{\"name\":\"vector\",\"length\":" << nvars << "},\"block\":\"transformed_parameters\"},{\"name\":\"alpha\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"gamma\",\"type\":{\"name\":\"array\",\"length\":" << 1 << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"loghr\",\"type\":{\"name\":\"vector\",\"length\":" << ncovs << "},\"block\":\"parameters\"},{\"name\":\"beta_err\",\"type\":{\"name\":\"vector\",\"length\":" << beta_err_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"smooth_sd\",\"type\":{\"name\":\"vector\",\"length\":" << est_smooth << "},\"block\":\"parameters\"},{\"name\":\"pcure\",\"type\":{\"name\":\"vector\",\"length\":" << cure << "},\"block\":\"parameters\"},{\"name\":\"logor_cure\",\"type\":{\"name\":\"vector\",\"length\":" << ncurecovs << "},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" << nvars << "},\"block\":\"transformed_parameters\"},{\"name\":\"coefs\",\"type\":{\"name\":\"vector\",\"length\":" << nvars << "},\"block\":\"transformed_parameters\"},{\"name\":\"alpha\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      std::vector<double> vars_vec(vars.size());
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i) {
        vars.coeffRef(i) = vars_vec[i];
      }
    }
    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }
    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
  
    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits_impl(context, params_i, params_r_vec, pstream);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i) {
        params_r.coeffRef(i) = params_r_vec[i];
      }
    }
    inline void transform_inits(const stan::io::var_context& context,
                                std::vector<int>& params_i,
                                std::vector<double>& vars,
                                std::ostream* pstream = nullptr) const final {
      transform_inits_impl(context, params_i, vars, pstream);
    }        
};
}
using stan_model = model_survextrap_namespace::model_survextrap;
#ifndef USING_R
// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return model_survextrap_namespace::profiles__;
}
#endif
#endif
