// Generated by rstantools.  Do not edit by hand.

/*
    survextrap is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    survextrap is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with survextrap.  If not, see <http://www.gnu.org/licenses/>.
*/
#ifndef MODELS_HPP
#define MODELS_HPP
#define STAN__SERVICES__COMMAND_HPP
#ifndef USE_STANC3
#define USE_STANC3
#endif
#include <rstan/rstaninc.hpp>
// Code generated by stanc v2.26.1-4-gd72b68b7-dirty
#include <stan/model/model_header.hpp>
namespace model_survextrap_namespace {
inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}
inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}
using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math;
using stan::math::pow; 
stan::math::profile_map profiles__;
static int current_statement__= 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'string', line 147, column 4 to column 24)",
                                                      " (in 'string', line 148, column 4 to column 24)",
                                                      " (in 'string', line 149, column 4 to column 26)",
                                                      " (in 'string', line 150, column 4 to column 33)",
                                                      " (in 'string', line 151, column 4 to column 40)",
                                                      " (in 'string', line 152, column 4 to column 33)",
                                                      " (in 'string', line 154, column 4 to column 40)",
                                                      " (in 'string', line 155, column 4 to column 40)",
                                                      " (in 'string', line 158, column 4 to column 20)",
                                                      " (in 'string', line 159, column 4 to column 24)",
                                                      " (in 'string', line 160, column 4 to column 37)",
                                                      " (in 'string', line 161, column 4 to column 37)",
                                                      " (in 'string', line 162, column 4 to column 39)",
                                                      " (in 'string', line 164, column 4 to column 33)",
                                                      " (in 'string', line 165, column 4 to column 33)",
                                                      " (in 'string', line 166, column 4 to column 35)",
                                                      " (in 'string', line 167, column 4 to column 31)",
                                                      " (in 'string', line 168, column 4 to column 13)",
                                                      " (in 'string', line 211, column 5 to column 52)",
                                                      " (in 'string', line 209, column 5 to column 46)",
                                                      " (in 'string', line 208, column 1 to line 211, column 52)",
                                                      " (in 'string', line 212, column 1 to column 20)",
                                                      " (in 'string', line 215, column 2 to column 48)",
                                                      " (in 'string', line 214, column 24 to line 216, column 6)",
                                                      " (in 'string', line 214, column 5 to line 216, column 6)",
                                                      " (in 'string', line 213, column 17 to line 217, column 2)",
                                                      " (in 'string', line 213, column 1 to line 217, column 2)",
                                                      " (in 'string', line 220, column 2 to column 48)",
                                                      " (in 'string', line 219, column 24 to line 221, column 6)",
                                                      " (in 'string', line 219, column 5 to line 221, column 6)",
                                                      " (in 'string', line 218, column 17 to line 222, column 2)",
                                                      " (in 'string', line 218, column 1 to line 222, column 2)",
                                                      " (in 'string', line 225, column 2 to column 49)",
                                                      " (in 'string', line 224, column 25 to line 226, column 6)",
                                                      " (in 'string', line 224, column 5 to line 226, column 6)",
                                                      " (in 'string', line 223, column 18 to line 227, column 2)",
                                                      " (in 'string', line 223, column 1 to line 227, column 2)",
                                                      " (in 'string', line 230, column 21 to column 64)",
                                                      " (in 'string', line 230, column 19 to column 66)",
                                                      " (in 'string', line 230, column 5 to column 66)",
                                                      " (in 'string', line 231, column 21 to column 64)",
                                                      " (in 'string', line 231, column 19 to column 66)",
                                                      " (in 'string', line 231, column 5 to column 66)",
                                                      " (in 'string', line 232, column 22 to column 68)",
                                                      " (in 'string', line 232, column 20 to column 70)",
                                                      " (in 'string', line 232, column 5 to column 70)",
                                                      " (in 'string', line 229, column 20 to line 233, column 2)",
                                                      " (in 'string', line 229, column 1 to line 233, column 2)",
                                                      " (in 'string', line 235, column 20 to column 58)",
                                                      " (in 'string', line 235, column 18 to column 60)",
                                                      " (in 'string', line 235, column 5 to column 60)",
                                                      " (in 'string', line 234, column 23 to line 236, column 2)",
                                                      " (in 'string', line 234, column 1 to line 236, column 2)",
                                                      " (in 'string', line 237, column 1 to column 9)",
                                                      " (in 'string', line 207, column 11 to line 238, column 5)",
                                                      " (in 'string', line 171, column 5 to column 56)",
                                                      " (in 'string', line 170, column 19 to line 172, column 2)",
                                                      " (in 'string', line 170, column 1 to line 172, column 2)",
                                                      " (in 'string', line 176, column 5 to column 24)",
                                                      " (in 'string', line 175, column 8 to line 177, column 2)",
                                                      " (in 'string', line 174, column 5 to column 18)",
                                                      " (in 'string', line 173, column 14 to line 175, column 2)",
                                                      " (in 'string', line 173, column 1 to line 177, column 2)",
                                                      " (in 'string', line 178, column 1 to column 39)",
                                                      " (in 'string', line 179, column 1 to column 20)",
                                                      " (in 'string', line 181, column 5 to column 48)",
                                                      " (in 'string', line 183, column 2 to column 70)",
                                                      " (in 'string', line 182, column 28 to line 184, column 6)",
                                                      " (in 'string', line 182, column 5 to line 184, column 6)",
                                                      " (in 'string', line 186, column 2 to column 81)",
                                                      " (in 'string', line 185, column 24 to line 187, column 6)",
                                                      " (in 'string', line 185, column 5 to line 187, column 6)",
                                                      " (in 'string', line 180, column 17 to line 188, column 2)",
                                                      " (in 'string', line 180, column 1 to line 188, column 2)",
                                                      " (in 'string', line 190, column 5 to column 48)",
                                                      " (in 'string', line 192, column 2 to column 70)",
                                                      " (in 'string', line 191, column 28 to line 193, column 6)",
                                                      " (in 'string', line 191, column 5 to line 193, column 6)",
                                                      " (in 'string', line 195, column 2 to column 81)",
                                                      " (in 'string', line 194, column 24 to line 196, column 6)",
                                                      " (in 'string', line 194, column 5 to line 196, column 6)",
                                                      " (in 'string', line 189, column 17 to line 197, column 2)",
                                                      " (in 'string', line 189, column 1 to line 197, column 2)",
                                                      " (in 'string', line 199, column 5 to column 51)",
                                                      " (in 'string', line 201, column 2 to column 70)",
                                                      " (in 'string', line 200, column 28 to line 202, column 6)",
                                                      " (in 'string', line 200, column 5 to line 202, column 6)",
                                                      " (in 'string', line 204, column 2 to column 83)",
                                                      " (in 'string', line 203, column 25 to line 205, column 6)",
                                                      " (in 'string', line 203, column 5 to line 205, column 6)",
                                                      " (in 'string', line 198, column 18 to line 206, column 2)",
                                                      " (in 'string', line 198, column 1 to line 206, column 2)",
                                                      " (in 'string', line 169, column 30 to line 207, column 5)",
                                                      " (in 'string', line 169, column 4 to line 238, column 5)",
                                                      " (in 'string', line 310, column 4 to column 44)",
                                                      " (in 'string', line 311, column 4 to column 34)",
                                                      " (in 'string', line 312, column 4 to column 48)",
                                                      " (in 'string', line 241, column 11 to column 17)",
                                                      " (in 'string', line 241, column 4 to column 31)",
                                                      " (in 'string', line 242, column 11 to column 17)",
                                                      " (in 'string', line 242, column 4 to column 31)",
                                                      " (in 'string', line 243, column 11 to column 18)",
                                                      " (in 'string', line 243, column 4 to column 33)",
                                                      " (in 'string', line 244, column 4 to column 15)",
                                                      " (in 'string', line 245, column 4 to column 12)",
                                                      " (in 'string', line 246, column 11 to column 18)",
                                                      " (in 'string', line 246, column 4 to column 31)",
                                                      " (in 'string', line 247, column 11 to column 18)",
                                                      " (in 'string', line 247, column 4 to column 32)",
                                                      " (in 'string', line 248, column 11 to column 17)",
                                                      " (in 'string', line 248, column 4 to column 31)",
                                                      " (in 'string', line 249, column 11 to column 17)",
                                                      " (in 'string', line 249, column 4 to column 31)",
                                                      " (in 'string', line 250, column 11 to column 18)",
                                                      " (in 'string', line 250, column 4 to column 33)",
                                                      " (in 'string', line 251, column 20 to column 81)",
                                                      " (in 'string', line 251, column 4 to column 81)",
                                                      " (in 'string', line 252, column 20 to column 81)",
                                                      " (in 'string', line 252, column 4 to column 81)",
                                                      " (in 'string', line 253, column 21 to column 84)",
                                                      " (in 'string', line 253, column 4 to column 84)",
                                                      " (in 'string', line 256, column 24 to column 55)",
                                                      " (in 'string', line 256, column 8 to column 55)",
                                                      " (in 'string', line 257, column 24 to column 55)",
                                                      " (in 'string', line 257, column 8 to column 55)",
                                                      " (in 'string', line 258, column 25 to column 55)",
                                                      " (in 'string', line 258, column 8 to column 55)",
                                                      " (in 'string', line 254, column 19 to line 259, column 5)",
                                                      " (in 'string', line 254, column 4 to line 259, column 5)",
                                                      " (in 'string', line 260, column 34 to column 41)",
                                                      " (in 'string', line 260, column 14 to column 28)",
                                                      " (in 'string', line 260, column 4 to column 41)",
                                                      " (in 'string', line 261, column 4 to column 41)",
                                                      " (in 'string', line 262, column 4 to column 41)",
                                                      " (in 'string', line 263, column 4 to column 43)",
                                                      " (in 'string', line 265, column 24 to column 95)",
                                                      " (in 'string', line 265, column 8 to column 95)",
                                                      " (in 'string', line 266, column 24 to column 95)",
                                                      " (in 'string', line 266, column 8 to column 95)",
                                                      " (in 'string', line 267, column 25 to column 96)",
                                                      " (in 'string', line 267, column 8 to column 96)",
                                                      " (in 'string', line 264, column 22 to line 268, column 5)",
                                                      " (in 'string', line 264, column 4 to line 268, column 5)",
                                                      " (in 'string', line 269, column 20 to line 270, column 53)",
                                                      " (in 'string', line 269, column 4 to line 270, column 53)",
                                                      " (in 'string', line 271, column 20 to line 272, column 14)",
                                                      " (in 'string', line 271, column 4 to line 272, column 14)",
                                                      " (in 'string', line 274, column 8 to line 275, column 37)",
                                                      " (in 'string', line 276, column 8 to line 277, column 39)",
                                                      " (in 'string', line 278, column 8 to column 74)",
                                                      " (in 'string', line 273, column 21 to line 279, column 5)",
                                                      " (in 'string', line 273, column 4 to line 279, column 5)",
                                                      " (in 'string', line 281, column 4 to line 282, column 42)",
                                                      " (in 'string', line 284, column 4 to line 285, column 50)",
                                                      " (in 'string', line 287, column 4 to column 27)",
                                                      " (in 'string', line 290, column 8 to column 51)",
                                                      " (in 'string', line 289, column 14 to line 291, column 5)",
                                                      " (in 'string', line 289, column 4 to line 291, column 5)",
                                                      " (in 'string', line 294, column 1 to line 295, column 49)",
                                                      " (in 'string', line 292, column 22 to line 296, column 5)",
                                                      " (in 'string', line 292, column 4 to line 296, column 5)",
                                                      " (in 'string', line 299, column 8 to column 48)",
                                                      " (in 'string', line 298, column 16 to line 300, column 5)",
                                                      " (in 'string', line 298, column 4 to line 300, column 5)",
                                                      " (in 'string', line 303, column 1 to column 46)",
                                                      " (in 'string', line 305, column 5 to column 41)",
                                                      " (in 'string', line 304, column 19 to line 306, column 2)",
                                                      " (in 'string', line 304, column 1 to line 306, column 2)",
                                                      " (in 'string', line 302, column 32 to line 307, column 5)",
                                                      " (in 'string', line 302, column 4 to line 307, column 5)",
                                                      " (in 'string', line 99, column 4 to column 24)",
                                                      " (in 'string', line 100, column 4 to column 24)",
                                                      " (in 'string', line 101, column 4 to column 23)",
                                                      " (in 'string', line 102, column 4 to column 25)",
                                                      " (in 'string', line 103, column 4 to column 23)",
                                                      " (in 'string', line 104, column 4 to column 27)",
                                                      " (in 'string', line 106, column 11 to column 17)",
                                                      " (in 'string', line 106, column 18 to column 23)",
                                                      " (in 'string', line 106, column 4 to column 37)",
                                                      " (in 'string', line 107, column 11 to column 17)",
                                                      " (in 'string', line 107, column 18 to column 23)",
                                                      " (in 'string', line 107, column 4 to column 38)",
                                                      " (in 'string', line 108, column 11 to column 17)",
                                                      " (in 'string', line 108, column 18 to column 23)",
                                                      " (in 'string', line 108, column 4 to column 38)",
                                                      " (in 'string', line 109, column 11 to column 18)",
                                                      " (in 'string', line 109, column 19 to column 24)",
                                                      " (in 'string', line 109, column 4 to column 42)",
                                                      " (in 'string', line 110, column 11 to column 18)",
                                                      " (in 'string', line 110, column 19 to column 24)",
                                                      " (in 'string', line 110, column 4 to column 43)",
                                                      " (in 'string', line 111, column 11 to column 17)",
                                                      " (in 'string', line 111, column 18 to column 23)",
                                                      " (in 'string', line 111, column 4 to column 33)",
                                                      " (in 'string', line 112, column 11 to column 17)",
                                                      " (in 'string', line 112, column 18 to column 23)",
                                                      " (in 'string', line 112, column 4 to column 33)",
                                                      " (in 'string', line 113, column 11 to column 17)",
                                                      " (in 'string', line 113, column 18 to column 27)",
                                                      " (in 'string', line 113, column 4 to column 41)",
                                                      " (in 'string', line 114, column 11 to column 17)",
                                                      " (in 'string', line 114, column 18 to column 27)",
                                                      " (in 'string', line 114, column 4 to column 41)",
                                                      " (in 'string', line 117, column 10 to column 17)",
                                                      " (in 'string', line 117, column 4 to column 38)",
                                                      " (in 'string', line 118, column 10 to column 17)",
                                                      " (in 'string', line 118, column 4 to column 38)",
                                                      " (in 'string', line 119, column 11 to column 18)",
                                                      " (in 'string', line 119, column 19 to column 24)",
                                                      " (in 'string', line 119, column 4 to column 32)",
                                                      " (in 'string', line 120, column 11 to column 18)",
                                                      " (in 'string', line 120, column 19 to column 28)",
                                                      " (in 'string', line 120, column 4 to column 40)",
                                                      " (in 'string', line 121, column 11 to column 18)",
                                                      " (in 'string', line 121, column 4 to column 27)",
                                                      " (in 'string', line 122, column 4 to column 16)",
                                                      " (in 'string', line 123, column 20 to column 29)",
                                                      " (in 'string', line 123, column 4 to column 41)",
                                                      " (in 'string', line 124, column 4 to column 13)",
                                                      " (in 'string', line 125, column 4 to column 17)",
                                                      " (in 'string', line 126, column 11 to column 17)",
                                                      " (in 'string', line 126, column 4 to column 33)",
                                                      " (in 'string', line 127, column 11 to column 18)",
                                                      " (in 'string', line 127, column 4 to column 39)",
                                                      " (in 'string', line 128, column 11 to column 18)",
                                                      " (in 'string', line 128, column 4 to column 38)",
                                                      " (in 'string', line 129, column 4 to column 26)",
                                                      " (in 'string', line 130, column 4 to column 27)",
                                                      " (in 'string', line 131, column 4 to column 34)",
                                                      " (in 'string', line 132, column 20 to column 29)",
                                                      " (in 'string', line 132, column 4 to column 41)",
                                                      " (in 'string', line 133, column 10 to column 15)",
                                                      " (in 'string', line 133, column 4 to column 47)",
                                                      " (in 'string', line 134, column 11 to column 16)",
                                                      " (in 'string', line 134, column 4 to column 39)",
                                                      " (in 'string', line 135, column 11 to column 16)",
                                                      " (in 'string', line 135, column 4 to column 36)",
                                                      " (in 'string', line 136, column 11 to column 16)",
                                                      " (in 'string', line 136, column 4 to column 33)",
                                                      " (in 'string', line 137, column 10 to column 19)",
                                                      " (in 'string', line 137, column 4 to column 56)",
                                                      " (in 'string', line 138, column 11 to column 20)",
                                                      " (in 'string', line 138, column 4 to column 48)",
                                                      " (in 'string', line 139, column 11 to column 20)",
                                                      " (in 'string', line 139, column 4 to column 45)",
                                                      " (in 'string', line 140, column 11 to column 20)",
                                                      " (in 'string', line 140, column 4 to column 42)",
                                                      " (in 'string', line 141, column 4 to column 16)",
                                                      " (in 'string', line 142, column 4 to column 16)",
                                                      " (in 'string', line 144, column 11 to column 24)",
                                                      " (in 'string', line 144, column 4 to column 39)",
                                                      " (in 'string', line 147, column 10 to column 11)",
                                                      " (in 'string', line 148, column 11 to column 16)",
                                                      " (in 'string', line 149, column 11 to column 18)",
                                                      " (in 'string', line 150, column 20 to column 27)",
                                                      " (in 'string', line 151, column 28 to column 32)",
                                                      " (in 'string', line 152, column 11 to column 20)",
                                                      " (in 'string', line 154, column 20 to column 33)",
                                                      " (in 'string', line 155, column 11 to column 24)",
                                                      " (in 'string', line 155, column 25 to column 32)",
                                                      " (in 'string', line 158, column 11 to column 16)",
                                                      " (in 'string', line 159, column 11 to column 16)",
                                                      " (in 'string', line 160, column 11 to column 17)",
                                                      " (in 'string', line 160, column 18 to column 23)",
                                                      " (in 'string', line 161, column 11 to column 17)",
                                                      " (in 'string', line 161, column 18 to column 23)",
                                                      " (in 'string', line 162, column 11 to column 18)",
                                                      " (in 'string', line 162, column 19 to column 24)",
                                                      " (in 'string', line 164, column 11 to column 17)",
                                                      " (in 'string', line 164, column 18 to column 23)",
                                                      " (in 'string', line 165, column 11 to column 17)",
                                                      " (in 'string', line 165, column 18 to column 23)",
                                                      " (in 'string', line 166, column 11 to column 18)",
                                                      " (in 'string', line 166, column 19 to column 24)",
                                                      " (in 'string', line 167, column 11 to column 16)",
                                                      " (in 'string', line 167, column 17 to column 24)",
                                                      " (in 'string', line 311, column 11 to column 16)",
                                                      " (in 'string', line 312, column 11 to column 20)",
                                                      " (in 'string', line 3, column 8 to column 59)",
                                                      " (in 'string', line 2, column 69 to line 4, column 5)",
                                                      " (in 'string', line 6, column 15 to column 26)",
                                                      " (in 'string', line 6, column 8 to column 32)",
                                                      " (in 'string', line 7, column 8 to column 64)",
                                                      " (in 'string', line 9, column 12 to column 96)",
                                                      " (in 'string', line 8, column 29 to line 10, column 9)",
                                                      " (in 'string', line 8, column 8 to line 10, column 9)",
                                                      " (in 'string', line 11, column 8 to column 19)",
                                                      " (in 'string', line 5, column 71 to line 12, column 5)",
                                                      " (in 'string', line 14, column 15 to column 26)",
                                                      " (in 'string', line 14, column 8 to column 32)",
                                                      " (in 'string', line 16, column 8 to line 17, column 47)",
                                                      " (in 'string', line 18, column 8 to column 19)",
                                                      " (in 'string', line 13, column 85 to line 19, column 5)",
                                                      " (in 'string', line 23, column 15 to column 26)",
                                                      " (in 'string', line 23, column 8 to column 32)",
                                                      " (in 'string', line 24, column 15 to column 26)",
                                                      " (in 'string', line 24, column 8 to column 41)",
                                                      " (in 'string', line 25, column 1 to column 55)",
                                                      " (in 'string', line 31, column 12 to column 31)",
                                                      " (in 'string', line 30, column 15 to line 32, column 9)",
                                                      " (in 'string', line 28, column 16 to column 77)",
                                                      " (in 'string', line 27, column 37 to line 29, column 13)",
                                                      " (in 'string', line 27, column 12 to line 29, column 13)",
                                                      " (in 'string', line 26, column 18 to line 30, column 9)",
                                                      " (in 'string', line 26, column 8 to line 32, column 9)",
                                                      " (in 'string', line 33, column 8 to column 19)",
                                                      " (in 'string', line 22, column 24 to line 34, column 5)",
                                                      " (in 'string', line 39, column 15 to column 26)",
                                                      " (in 'string', line 39, column 8 to column 32)",
                                                      " (in 'string', line 40, column 15 to column 26)",
                                                      " (in 'string', line 40, column 8 to column 41)",
                                                      " (in 'string', line 41, column 15 to column 26)",
                                                      " (in 'string', line 41, column 8 to column 40)",
                                                      " (in 'string', line 42, column 15 to column 26)",
                                                      " (in 'string', line 42, column 8 to column 36)",
                                                      " (in 'string', line 50, column 5 to column 56)",
                                                      " (in 'string', line 51, column 12 to column 30)",
                                                      " (in 'string', line 49, column 15 to line 52, column 9)",
                                                      " (in 'string', line 44, column 5 to column 66)",
                                                      " (in 'string', line 45, column 12 to column 75)",
                                                      " (in 'string', line 47, column 16 to column 74)",
                                                      " (in 'string', line 46, column 36 to line 48, column 13)",
                                                      " (in 'string', line 46, column 12 to line 48, column 13)",
                                                      " (in 'string', line 43, column 18 to line 49, column 9)",
                                                      " (in 'string', line 43, column 8 to line 52, column 9)",
                                                      " (in 'string', line 55, column 2 to column 41)",
                                                      " (in 'string', line 54, column 29 to line 56, column 6)",
                                                      " (in 'string', line 54, column 5 to line 56, column 6)",
                                                      " (in 'string', line 53, column 15 to line 57, column 2)",
                                                      " (in 'string', line 53, column 1 to line 57, column 2)",
                                                      " (in 'string', line 58, column 8 to column 19)",
                                                      " (in 'string', line 38, column 21 to line 59, column 5)",
                                                      " (in 'string', line 64, column 15 to column 26)",
                                                      " (in 'string', line 64, column 8 to column 32)",
                                                      " (in 'string', line 65, column 8 to line 66, column 58)",
                                                      " (in 'string', line 67, column 8 to column 19)",
                                                      " (in 'string', line 63, column 40 to line 68, column 5)",
                                                      " (in 'string', line 83, column 8 to column 62)",
                                                      " (in 'string', line 82, column 13 to line 83, column 62)",
                                                      " (in 'string', line 81, column 8 to column 55)",
                                                      " (in 'string', line 80, column 8 to line 83, column 62)",
                                                      " (in 'string', line 85, column 8 to column 24)",
                                                      " (in 'string', line 79, column 77 to line 86, column 5)",
                                                      " (in 'string', line 92, column 2 to column 68)",
                                                      " (in 'string', line 91, column 10 to line 92, column 68)",
                                                      " (in 'string', line 90, column 2 to column 58)",
                                                      " (in 'string', line 89, column 5 to line 92, column 68)",
                                                      " (in 'string', line 88, column 25 to line 93, column 2)",
                                                      " (in 'string', line 88, column 1 to line 93, column 2)",
                                                      " (in 'string', line 95, column 8 to column 24)",
                                                      " (in 'string', line 87, column 86 to line 96, column 5)"};
template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>, stan::value_type_t<T1__>,
stan::value_type_t<T2__>>, -1, 1>
mspline_log_haz(const T0__& alpha_arg__, const T1__& basis_arg__,
                const T2__& coefs_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>,
          stan::value_type_t<T1__>,
          stan::value_type_t<T2__>>;
  const auto& alpha = to_ref(alpha_arg__);
  const auto& basis = to_ref(basis_arg__);
  const auto& coefs = to_ref(coefs_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 279;
    return add(stan::math::log(rows_dot_product(basis, coefs)), alpha);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct mspline_log_haz_functor__ {
template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>, stan::value_type_t<T1__>,
stan::value_type_t<T2__>>, -1, 1>
operator()(const T0__& alpha, const T1__& basis, const T2__& coefs,
           std::ostream* pstream__)  const 
{
return mspline_log_haz(alpha, basis, coefs, pstream__);
}
};
template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>, stan::value_type_t<T1__>,
stan::value_type_t<T2__>>, -1, 1>
mspline_log_surv(const T0__& alpha_arg__, const T1__& ibasis_arg__,
                 const T2__& coefs_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>,
          stan::value_type_t<T1__>,
          stan::value_type_t<T2__>>;
  const auto& alpha = to_ref(alpha_arg__);
  const auto& ibasis = to_ref(ibasis_arg__);
  const auto& coefs = to_ref(coefs_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 281;
    validate_non_negative_index("res", "rows(alpha)", rows(alpha));
    Eigen::Matrix<local_scalar_t__, -1, 1> res;
    res = Eigen::Matrix<local_scalar_t__, -1, 1>(rows(alpha));
    stan::math::fill(res, DUMMY_VAR__);
    
    current_statement__ = 283;
    assign(res, nil_index_list(),
      elt_multiply(minus(rows_dot_product(ibasis, coefs)),
        stan::math::exp(alpha)), "assigning variable res");
    current_statement__ = 286;
    if (logical_gt(stan::math::exp(res[(1 - 1)]), 1)) {
      current_statement__ = 284;
      std::stringstream errmsg_stream__;
      errmsg_stream__ << "Probability > 1 computed. Not your fault - report a bug to the developer.";
      throw std::domain_error(errmsg_stream__.str());
    } 
    current_statement__ = 287;
    return res;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct mspline_log_surv_functor__ {
template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>, stan::value_type_t<T1__>,
stan::value_type_t<T2__>>, -1, 1>
operator()(const T0__& alpha, const T1__& ibasis, const T2__& coefs,
           std::ostream* pstream__)  const 
{
return mspline_log_surv(alpha, ibasis, coefs, pstream__);
}
};
template <typename T0__, typename T1__, typename T2__, typename T3__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>, stan::value_type_t<T1__>,
stan::value_type_t<T2__>,
stan::value_type_t<T3__>>, -1, 1>
mspline_log_dens(const T0__& alpha_arg__, const T1__& basis_arg__,
                 const T2__& ibasis_arg__, const T3__& coefs_arg__,
                 std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>,
          stan::value_type_t<T1__>,
          stan::value_type_t<T2__>,
          stan::value_type_t<T3__>>;
  const auto& alpha = to_ref(alpha_arg__);
  const auto& basis = to_ref(basis_arg__);
  const auto& ibasis = to_ref(ibasis_arg__);
  const auto& coefs = to_ref(coefs_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 289;
    validate_non_negative_index("res", "rows(alpha)", rows(alpha));
    Eigen::Matrix<local_scalar_t__, -1, 1> res;
    res = Eigen::Matrix<local_scalar_t__, -1, 1>(rows(alpha));
    stan::math::fill(res, DUMMY_VAR__);
    
    current_statement__ = 291;
    assign(res, nil_index_list(),
      add(mspline_log_haz(alpha, basis, coefs, pstream__),
        mspline_log_surv(alpha, ibasis, coefs, pstream__)),
      "assigning variable res");
    current_statement__ = 292;
    return res;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct mspline_log_dens_functor__ {
template <typename T0__, typename T1__, typename T2__, typename T3__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>, stan::value_type_t<T1__>,
stan::value_type_t<T2__>,
stan::value_type_t<T3__>>, -1, 1>
operator()(const T0__& alpha, const T1__& basis, const T2__& ibasis,
           const T3__& coefs, std::ostream* pstream__)  const 
{
return mspline_log_dens(alpha, basis, ibasis, coefs, pstream__);
}
};
template <typename T0__, typename T1__, typename T2__, typename T4__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>, stan::value_type_t<T1__>,
stan::value_type_t<T2__>,
stan::value_type_t<T4__>>, -1, 1>
log_surv(const T0__& alpha_arg__, const T1__& ibasis_arg__,
         const T2__& coefs_arg__, const int& cure, const T4__& pcure_arg__,
         const int& modelid, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>,
          stan::value_type_t<T1__>,
          stan::value_type_t<T2__>,
          stan::value_type_t<T4__>>;
  const auto& alpha = to_ref(alpha_arg__);
  const auto& ibasis = to_ref(ibasis_arg__);
  const auto& coefs = to_ref(coefs_arg__);
  const auto& pcure = to_ref(pcure_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 294;
    validate_non_negative_index("res", "rows(alpha)", rows(alpha));
    Eigen::Matrix<local_scalar_t__, -1, 1> res;
    res = Eigen::Matrix<local_scalar_t__, -1, 1>(rows(alpha));
    stan::math::fill(res, DUMMY_VAR__);
    
    current_statement__ = 296;
    validate_non_negative_index("base_logsurv", "rows(alpha)", rows(alpha));
    Eigen::Matrix<local_scalar_t__, -1, 1> base_logsurv;
    base_logsurv = Eigen::Matrix<local_scalar_t__, -1, 1>(rows(alpha));
    stan::math::fill(base_logsurv, DUMMY_VAR__);
    
    current_statement__ = 298;
    assign(base_logsurv, nil_index_list(),
      mspline_log_surv(alpha, ibasis, coefs, pstream__),
      "assigning variable base_logsurv");
    current_statement__ = 305;
    if (cure) {
      current_statement__ = 303;
      for (int i = 1; i <= rows(alpha); ++i) {
        current_statement__ = 301;
        assign(res, cons_list(index_uni(i), nil_index_list()),
          stan::math::log(
            (pcure[(i - 1)] +
              ((1 - pcure[(i - 1)]) * stan::math::exp(base_logsurv[(i - 1)])))),
          "assigning variable res");}
    } else {
      current_statement__ = 299;
      assign(res, nil_index_list(), base_logsurv, "assigning variable res");
    }
    current_statement__ = 306;
    return res;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct log_surv_functor__ {
template <typename T0__, typename T1__, typename T2__, typename T4__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>, stan::value_type_t<T1__>,
stan::value_type_t<T2__>,
stan::value_type_t<T4__>>, -1, 1>
operator()(const T0__& alpha, const T1__& ibasis, const T2__& coefs,
           const int& cure, const T4__& pcure, const int& modelid,
           std::ostream* pstream__)  const 
{
return log_surv(alpha, ibasis, coefs, cure, pcure, modelid, pstream__);
}
};
template <typename T0__, typename T1__, typename T2__, typename T4__,
typename T5__, typename T8__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>, stan::value_type_t<T1__>,
stan::value_type_t<T2__>, stan::value_type_t<T4__>,
stan::value_type_t<T5__>, stan::promote_args_t<stan::value_type_t<T8__>>>, -1, 1>
log_haz(const T0__& alpha_arg__, const T1__& basis_arg__,
        const T2__& coefs_arg__, const int& cure, const T4__& pcure_arg__,
        const T5__& ibasis_arg__, const int& modelid, const int& relative,
        const T8__& backhaz_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>,
          stan::value_type_t<T1__>,
          stan::value_type_t<T2__>,
          stan::value_type_t<T4__>,
          stan::value_type_t<T5__>, stan::promote_args_t<stan::value_type_t<T8__>>>;
  const auto& alpha = to_ref(alpha_arg__);
  const auto& basis = to_ref(basis_arg__);
  const auto& coefs = to_ref(coefs_arg__);
  const auto& pcure = to_ref(pcure_arg__);
  const auto& ibasis = to_ref(ibasis_arg__);
  const auto& backhaz = to_ref(backhaz_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 308;
    validate_non_negative_index("res", "rows(alpha)", rows(alpha));
    Eigen::Matrix<local_scalar_t__, -1, 1> res;
    res = Eigen::Matrix<local_scalar_t__, -1, 1>(rows(alpha));
    stan::math::fill(res, DUMMY_VAR__);
    
    current_statement__ = 310;
    validate_non_negative_index("base_logdens", "rows(alpha)", rows(alpha));
    Eigen::Matrix<local_scalar_t__, -1, 1> base_logdens;
    base_logdens = Eigen::Matrix<local_scalar_t__, -1, 1>(rows(alpha));
    stan::math::fill(base_logdens, DUMMY_VAR__);
    
    current_statement__ = 312;
    validate_non_negative_index("base_loghaz", "rows(alpha)", rows(alpha));
    Eigen::Matrix<local_scalar_t__, -1, 1> base_loghaz;
    base_loghaz = Eigen::Matrix<local_scalar_t__, -1, 1>(rows(alpha));
    stan::math::fill(base_loghaz, DUMMY_VAR__);
    
    current_statement__ = 314;
    validate_non_negative_index("logsurv", "rows(alpha)", rows(alpha));
    Eigen::Matrix<local_scalar_t__, -1, 1> logsurv;
    logsurv = Eigen::Matrix<local_scalar_t__, -1, 1>(rows(alpha));
    stan::math::fill(logsurv, DUMMY_VAR__);
    
    current_statement__ = 325;
    if (cure) {
      current_statement__ = 319;
      assign(base_logdens, nil_index_list(),
        mspline_log_dens(alpha, basis, ibasis, coefs, pstream__),
        "assigning variable base_logdens");
      current_statement__ = 320;
      assign(logsurv, nil_index_list(),
        log_surv(alpha, ibasis, coefs, cure, pcure, modelid, pstream__),
        "assigning variable logsurv");
      current_statement__ = 323;
      for (int i = 1; i <= rows(alpha); ++i) {
        current_statement__ = 321;
        assign(res, cons_list(index_uni(i), nil_index_list()),
          ((stan::math::log((1 - pcure[(i - 1)])) + base_logdens[(i - 1)]) -
            logsurv[(i - 1)]), "assigning variable res");}
    } else {
      current_statement__ = 316;
      assign(base_loghaz, nil_index_list(),
        mspline_log_haz(alpha, basis, coefs, pstream__),
        "assigning variable base_loghaz");
      current_statement__ = 317;
      assign(res, nil_index_list(), base_loghaz, "assigning variable res");
    }
    current_statement__ = 330;
    if (relative) {
      current_statement__ = 328;
      for (int i = 1; i <= rows(alpha); ++i) {
        current_statement__ = 326;
        assign(res, cons_list(index_uni(i), nil_index_list()),
          stan::math::log((backhaz[(i - 1)] + stan::math::exp(res[(i - 1)]))),
          "assigning variable res");}
    } 
    current_statement__ = 331;
    return res;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct log_haz_functor__ {
template <typename T0__, typename T1__, typename T2__, typename T4__,
typename T5__, typename T8__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>, stan::value_type_t<T1__>,
stan::value_type_t<T2__>, stan::value_type_t<T4__>,
stan::value_type_t<T5__>, stan::promote_args_t<stan::value_type_t<T8__>>>, -1, 1>
operator()(const T0__& alpha, const T1__& basis, const T2__& coefs,
           const int& cure, const T4__& pcure, const T5__& ibasis,
           const int& modelid, const int& relative, const T8__& backhaz,
           std::ostream* pstream__)  const 
{
return log_haz(alpha, basis, coefs, cure, pcure, ibasis, modelid, relative,
         backhaz, pstream__);
}
};
template <typename T0__, typename T1__, typename T2__, typename T4__,
typename T5__, typename T8__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>, stan::value_type_t<T1__>,
stan::value_type_t<T2__>, stan::value_type_t<T4__>,
stan::value_type_t<T5__>, stan::promote_args_t<stan::value_type_t<T8__>>>, -1, 1>
log_dens(const T0__& alpha_arg__, const T1__& basis_arg__,
         const T2__& coefs_arg__, const int& cure, const T4__& pcure_arg__,
         const T5__& ibasis_arg__, const int& modelid, const int& relative,
         const T8__& backhaz_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>,
          stan::value_type_t<T1__>,
          stan::value_type_t<T2__>,
          stan::value_type_t<T4__>,
          stan::value_type_t<T5__>, stan::promote_args_t<stan::value_type_t<T8__>>>;
  const auto& alpha = to_ref(alpha_arg__);
  const auto& basis = to_ref(basis_arg__);
  const auto& coefs = to_ref(coefs_arg__);
  const auto& pcure = to_ref(pcure_arg__);
  const auto& ibasis = to_ref(ibasis_arg__);
  const auto& backhaz = to_ref(backhaz_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 333;
    validate_non_negative_index("res", "rows(alpha)", rows(alpha));
    Eigen::Matrix<local_scalar_t__, -1, 1> res;
    res = Eigen::Matrix<local_scalar_t__, -1, 1>(rows(alpha));
    stan::math::fill(res, DUMMY_VAR__);
    
    current_statement__ = 335;
    assign(res, nil_index_list(),
      add(
        log_haz(alpha, basis, coefs, cure, pcure, ibasis, modelid, relative,
          backhaz, pstream__),
        log_surv(alpha, ibasis, coefs, cure, pcure, modelid, pstream__)),
      "assigning variable res");
    current_statement__ = 336;
    return res;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct log_dens_functor__ {
template <typename T0__, typename T1__, typename T2__, typename T4__,
typename T5__, typename T8__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>, stan::value_type_t<T1__>,
stan::value_type_t<T2__>, stan::value_type_t<T4__>,
stan::value_type_t<T5__>, stan::promote_args_t<stan::value_type_t<T8__>>>, -1, 1>
operator()(const T0__& alpha, const T1__& basis, const T2__& coefs,
           const int& cure, const T4__& pcure, const T5__& ibasis,
           const int& modelid, const int& relative, const T8__& backhaz,
           std::ostream* pstream__)  const 
{
return log_dens(alpha, basis, coefs, cure, pcure, ibasis, modelid, relative,
         backhaz, pstream__);
}
};
template <bool propto__, typename T0__, typename T2__, typename T3__,
typename T4__, typename T_lp__, typename T_lp_accum__>
stan::promote_args_t<T0__, T2__, T3__,
T4__>
loghaz_lp(const T0__& gamma, const int& dist, const T2__& location,
          const T3__& scale, const T4__& df, T_lp__& lp__,
          T_lp_accum__& lp_accum__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T2__, T3__, T4__>;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 341;
    if (logical_eq(dist, 1)) {
      current_statement__ = 340;
      lp_accum__.add(normal_lpdf<false>(gamma, location, scale));
    } else {
      current_statement__ = 339;
      if (logical_eq(dist, 2)) {
        current_statement__ = 338;
        lp_accum__.add(student_t_lpdf<false>(gamma, df, location, scale));
      } 
    }
    current_statement__ = 342;
    return get_lp(lp__, lp_accum__);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct loghaz_lp_functor__ {
template <bool propto__, typename T0__, typename T2__, typename T3__,
typename T4__, typename T_lp__, typename T_lp_accum__>
stan::promote_args_t<T0__, T2__, T3__,
T4__>
operator()(const T0__& gamma, const int& dist, const T2__& location,
           const T3__& scale, const T4__& df, T_lp__& lp__,
           T_lp_accum__& lp_accum__, std::ostream* pstream__)  const 
{
return loghaz_lp<propto__>(gamma, dist, location, scale, df, lp__,
         lp_accum__, pstream__);
}
};
template <bool propto__, typename T0__, typename T2__, typename T3__,
typename T4__, typename T_lp__, typename T_lp_accum__>
stan::promote_args_t<stan::value_type_t<T0__>, stan::value_type_t<T2__>,
stan::value_type_t<T3__>,
stan::value_type_t<T4__>>
loghr_lp(const T0__& loghr_arg__, const std::vector<int>& dist,
         const T2__& location_arg__, const T3__& scale_arg__,
         const T4__& df_arg__, T_lp__& lp__, T_lp_accum__& lp_accum__,
         std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>,
          stan::value_type_t<T2__>,
          stan::value_type_t<T3__>,
          stan::value_type_t<T4__>>;
  const auto& loghr = to_ref(loghr_arg__);
  const auto& location = to_ref(location_arg__);
  const auto& scale = to_ref(scale_arg__);
  const auto& df = to_ref(df_arg__);
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 349;
    for (int i = 1; i <= rows(loghr); ++i) {
      current_statement__ = 347;
      if (logical_eq(dist[(i - 1)], 1)) {
        current_statement__ = 346;
        lp_accum__.add(
          normal_lpdf<false>(loghr[(i - 1)], location[(i - 1)],
            scale[(i - 1)]));
      } else {
        current_statement__ = 345;
        if (logical_eq(dist[(i - 1)], 2)) {
          current_statement__ = 344;
          lp_accum__.add(
            student_t_lpdf<false>(loghr[(i - 1)], df[(i - 1)],
              location[(i - 1)], scale[(i - 1)]));
        } 
      }}
    current_statement__ = 350;
    return get_lp(lp__, lp_accum__);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct loghr_lp_functor__ {
template <bool propto__, typename T0__, typename T2__, typename T3__,
typename T4__, typename T_lp__, typename T_lp_accum__>
stan::promote_args_t<stan::value_type_t<T0__>, stan::value_type_t<T2__>,
stan::value_type_t<T3__>,
stan::value_type_t<T4__>>
operator()(const T0__& loghr, const std::vector<int>& dist,
           const T2__& location, const T3__& scale, const T4__& df,
           T_lp__& lp__, T_lp_accum__& lp_accum__, std::ostream* pstream__)  const 
{
return loghr_lp<propto__>(loghr, dist, location, scale, df, lp__, lp_accum__,
         pstream__);
}
};
#include <stan_meta_header.hpp>
class model_survextrap final : public model_base_crtp<model_survextrap> {
private:
  int nevent;
  int nrcens;
  int nvars;
  int nextern;
  int ncovs;
  int ncurecovs;
  Eigen::Matrix<double, -1, -1> basis_event;
  Eigen::Matrix<double, -1, -1> ibasis_event;
  Eigen::Matrix<double, -1, -1> ibasis_rcens;
  Eigen::Matrix<double, -1, -1> ibasis_ext_stop;
  Eigen::Matrix<double, -1, -1> ibasis_ext_start;
  Eigen::Matrix<double, -1, -1> x_event;
  Eigen::Matrix<double, -1, -1> x_rcens;
  Eigen::Matrix<double, -1, -1> xcure_event;
  Eigen::Matrix<double, -1, -1> xcure_rcens;
  std::vector<int> r_ext;
  std::vector<int> n_ext;
  Eigen::Matrix<double, -1, -1> x_ext;
  Eigen::Matrix<double, -1, -1> xcure_ext;
  Eigen::Matrix<double, -1, 1> b_mean;
  int est_hsd;
  Eigen::Matrix<double, -1, 1> hsd_fixed;
  int cure;
  int relative;
  Eigen::Matrix<double, -1, 1> backhaz_event;
  Eigen::Matrix<double, -1, 1> backsurv_ext_start;
  Eigen::Matrix<double, -1, 1> backsurv_ext_stop;
  int prior_hscale_dist;
  Eigen::Matrix<double, -1, 1> prior_hscale;
  Eigen::Matrix<double, -1, 1> prior_cure;
  Eigen::Matrix<double, -1, 1> prior_hsd;
  std::vector<int> prior_loghr_dist;
  Eigen::Matrix<double, -1, 1> prior_loghr_location;
  Eigen::Matrix<double, -1, 1> prior_loghr_scale;
  Eigen::Matrix<double, -1, 1> prior_loghr_df;
  std::vector<int> prior_logor_cure_dist;
  Eigen::Matrix<double, -1, 1> prior_logor_cure_location;
  Eigen::Matrix<double, -1, 1> prior_logor_cure_scale;
  Eigen::Matrix<double, -1, 1> prior_logor_cure_df;
  int modelid;
  int nonprop;
  Eigen::Matrix<double, -1, -1> prior_hrsd;
  int b_err_1dim__;
  int hrsd_1dim__;
  int nperr_1dim__;
  int nperr_2dim__;
  int b_np_2dim__;
 
public:
  ~model_survextrap() { }
  
  inline std::string model_name() const final { return "model_survextrap"; }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = stanc3 v2.26.1-4-gd72b68b7-dirty", "stancflags = "};
  }
  
  
  model_survextrap(stan::io::var_context& context__,
                   unsigned int random_seed__ = 0,
                   std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "model_survextrap_namespace::model_survextrap";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      current_statement__ = 171;
      context__.validate_dims("data initialization","nevent","int",
          context__.to_vec());
      nevent = std::numeric_limits<int>::min();
      
      current_statement__ = 171;
      nevent = context__.vals_i("nevent")[(1 - 1)];
      current_statement__ = 171;
      current_statement__ = 171;
      check_greater_or_equal(function__, "nevent", nevent, 0);
      current_statement__ = 172;
      context__.validate_dims("data initialization","nrcens","int",
          context__.to_vec());
      nrcens = std::numeric_limits<int>::min();
      
      current_statement__ = 172;
      nrcens = context__.vals_i("nrcens")[(1 - 1)];
      current_statement__ = 172;
      current_statement__ = 172;
      check_greater_or_equal(function__, "nrcens", nrcens, 0);
      current_statement__ = 173;
      context__.validate_dims("data initialization","nvars","int",
          context__.to_vec());
      nvars = std::numeric_limits<int>::min();
      
      current_statement__ = 173;
      nvars = context__.vals_i("nvars")[(1 - 1)];
      current_statement__ = 173;
      current_statement__ = 173;
      check_greater_or_equal(function__, "nvars", nvars, 0);
      current_statement__ = 174;
      context__.validate_dims("data initialization","nextern","int",
          context__.to_vec());
      nextern = std::numeric_limits<int>::min();
      
      current_statement__ = 174;
      nextern = context__.vals_i("nextern")[(1 - 1)];
      current_statement__ = 174;
      current_statement__ = 174;
      check_greater_or_equal(function__, "nextern", nextern, 0);
      current_statement__ = 175;
      context__.validate_dims("data initialization","ncovs","int",
          context__.to_vec());
      ncovs = std::numeric_limits<int>::min();
      
      current_statement__ = 175;
      ncovs = context__.vals_i("ncovs")[(1 - 1)];
      current_statement__ = 175;
      current_statement__ = 175;
      check_greater_or_equal(function__, "ncovs", ncovs, 0);
      current_statement__ = 176;
      context__.validate_dims("data initialization","ncurecovs","int",
          context__.to_vec());
      ncurecovs = std::numeric_limits<int>::min();
      
      current_statement__ = 176;
      ncurecovs = context__.vals_i("ncurecovs")[(1 - 1)];
      current_statement__ = 176;
      current_statement__ = 176;
      check_greater_or_equal(function__, "ncurecovs", ncurecovs, 0);
      current_statement__ = 177;
      validate_non_negative_index("basis_event", "nevent", nevent);
      current_statement__ = 178;
      validate_non_negative_index("basis_event", "nvars", nvars);
      current_statement__ = 179;
      context__.validate_dims("data initialization","basis_event","double",
          context__.to_vec(nevent, nvars));
      basis_event = Eigen::Matrix<double, -1, -1>(nevent, nvars);
      stan::math::fill(basis_event, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> basis_event_flat__;
        current_statement__ = 179;
        assign(basis_event_flat__, nil_index_list(),
          context__.vals_r("basis_event"),
          "assigning variable basis_event_flat__");
        current_statement__ = 179;
        pos__ = 1;
        current_statement__ = 179;
        for (int sym1__ = 1; sym1__ <= nvars; ++sym1__) {
          current_statement__ = 179;
          for (int sym2__ = 1; sym2__ <= nevent; ++sym2__) {
            current_statement__ = 179;
            assign(basis_event,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              basis_event_flat__[(pos__ - 1)],
              "assigning variable basis_event");
            current_statement__ = 179;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 180;
      validate_non_negative_index("ibasis_event", "nevent", nevent);
      current_statement__ = 181;
      validate_non_negative_index("ibasis_event", "nvars", nvars);
      current_statement__ = 182;
      context__.validate_dims("data initialization","ibasis_event","double",
          context__.to_vec(nevent, nvars));
      ibasis_event = Eigen::Matrix<double, -1, -1>(nevent, nvars);
      stan::math::fill(ibasis_event, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> ibasis_event_flat__;
        current_statement__ = 182;
        assign(ibasis_event_flat__, nil_index_list(),
          context__.vals_r("ibasis_event"),
          "assigning variable ibasis_event_flat__");
        current_statement__ = 182;
        pos__ = 1;
        current_statement__ = 182;
        for (int sym1__ = 1; sym1__ <= nvars; ++sym1__) {
          current_statement__ = 182;
          for (int sym2__ = 1; sym2__ <= nevent; ++sym2__) {
            current_statement__ = 182;
            assign(ibasis_event,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              ibasis_event_flat__[(pos__ - 1)],
              "assigning variable ibasis_event");
            current_statement__ = 182;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 183;
      validate_non_negative_index("ibasis_rcens", "nrcens", nrcens);
      current_statement__ = 184;
      validate_non_negative_index("ibasis_rcens", "nvars", nvars);
      current_statement__ = 185;
      context__.validate_dims("data initialization","ibasis_rcens","double",
          context__.to_vec(nrcens, nvars));
      ibasis_rcens = Eigen::Matrix<double, -1, -1>(nrcens, nvars);
      stan::math::fill(ibasis_rcens, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> ibasis_rcens_flat__;
        current_statement__ = 185;
        assign(ibasis_rcens_flat__, nil_index_list(),
          context__.vals_r("ibasis_rcens"),
          "assigning variable ibasis_rcens_flat__");
        current_statement__ = 185;
        pos__ = 1;
        current_statement__ = 185;
        for (int sym1__ = 1; sym1__ <= nvars; ++sym1__) {
          current_statement__ = 185;
          for (int sym2__ = 1; sym2__ <= nrcens; ++sym2__) {
            current_statement__ = 185;
            assign(ibasis_rcens,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              ibasis_rcens_flat__[(pos__ - 1)],
              "assigning variable ibasis_rcens");
            current_statement__ = 185;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 186;
      validate_non_negative_index("ibasis_ext_stop", "nextern", nextern);
      current_statement__ = 187;
      validate_non_negative_index("ibasis_ext_stop", "nvars", nvars);
      current_statement__ = 188;
      context__.validate_dims("data initialization","ibasis_ext_stop",
          "double",context__.to_vec(nextern, nvars));
      ibasis_ext_stop = Eigen::Matrix<double, -1, -1>(nextern, nvars);
      stan::math::fill(ibasis_ext_stop, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> ibasis_ext_stop_flat__;
        current_statement__ = 188;
        assign(ibasis_ext_stop_flat__, nil_index_list(),
          context__.vals_r("ibasis_ext_stop"),
          "assigning variable ibasis_ext_stop_flat__");
        current_statement__ = 188;
        pos__ = 1;
        current_statement__ = 188;
        for (int sym1__ = 1; sym1__ <= nvars; ++sym1__) {
          current_statement__ = 188;
          for (int sym2__ = 1; sym2__ <= nextern; ++sym2__) {
            current_statement__ = 188;
            assign(ibasis_ext_stop,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              ibasis_ext_stop_flat__[(pos__ - 1)],
              "assigning variable ibasis_ext_stop");
            current_statement__ = 188;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 189;
      validate_non_negative_index("ibasis_ext_start", "nextern", nextern);
      current_statement__ = 190;
      validate_non_negative_index("ibasis_ext_start", "nvars", nvars);
      current_statement__ = 191;
      context__.validate_dims("data initialization","ibasis_ext_start",
          "double",context__.to_vec(nextern, nvars));
      ibasis_ext_start = Eigen::Matrix<double, -1, -1>(nextern, nvars);
      stan::math::fill(ibasis_ext_start, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> ibasis_ext_start_flat__;
        current_statement__ = 191;
        assign(ibasis_ext_start_flat__, nil_index_list(),
          context__.vals_r("ibasis_ext_start"),
          "assigning variable ibasis_ext_start_flat__");
        current_statement__ = 191;
        pos__ = 1;
        current_statement__ = 191;
        for (int sym1__ = 1; sym1__ <= nvars; ++sym1__) {
          current_statement__ = 191;
          for (int sym2__ = 1; sym2__ <= nextern; ++sym2__) {
            current_statement__ = 191;
            assign(ibasis_ext_start,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              ibasis_ext_start_flat__[(pos__ - 1)],
              "assigning variable ibasis_ext_start");
            current_statement__ = 191;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 192;
      validate_non_negative_index("x_event", "nevent", nevent);
      current_statement__ = 193;
      validate_non_negative_index("x_event", "ncovs", ncovs);
      current_statement__ = 194;
      context__.validate_dims("data initialization","x_event","double",
          context__.to_vec(nevent, ncovs));
      x_event = Eigen::Matrix<double, -1, -1>(nevent, ncovs);
      stan::math::fill(x_event, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> x_event_flat__;
        current_statement__ = 194;
        assign(x_event_flat__, nil_index_list(), context__.vals_r("x_event"),
          "assigning variable x_event_flat__");
        current_statement__ = 194;
        pos__ = 1;
        current_statement__ = 194;
        for (int sym1__ = 1; sym1__ <= ncovs; ++sym1__) {
          current_statement__ = 194;
          for (int sym2__ = 1; sym2__ <= nevent; ++sym2__) {
            current_statement__ = 194;
            assign(x_event,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              x_event_flat__[(pos__ - 1)], "assigning variable x_event");
            current_statement__ = 194;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 195;
      validate_non_negative_index("x_rcens", "nrcens", nrcens);
      current_statement__ = 196;
      validate_non_negative_index("x_rcens", "ncovs", ncovs);
      current_statement__ = 197;
      context__.validate_dims("data initialization","x_rcens","double",
          context__.to_vec(nrcens, ncovs));
      x_rcens = Eigen::Matrix<double, -1, -1>(nrcens, ncovs);
      stan::math::fill(x_rcens, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> x_rcens_flat__;
        current_statement__ = 197;
        assign(x_rcens_flat__, nil_index_list(), context__.vals_r("x_rcens"),
          "assigning variable x_rcens_flat__");
        current_statement__ = 197;
        pos__ = 1;
        current_statement__ = 197;
        for (int sym1__ = 1; sym1__ <= ncovs; ++sym1__) {
          current_statement__ = 197;
          for (int sym2__ = 1; sym2__ <= nrcens; ++sym2__) {
            current_statement__ = 197;
            assign(x_rcens,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              x_rcens_flat__[(pos__ - 1)], "assigning variable x_rcens");
            current_statement__ = 197;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 198;
      validate_non_negative_index("xcure_event", "nevent", nevent);
      current_statement__ = 199;
      validate_non_negative_index("xcure_event", "ncurecovs", ncurecovs);
      current_statement__ = 200;
      context__.validate_dims("data initialization","xcure_event","double",
          context__.to_vec(nevent, ncurecovs));
      xcure_event = Eigen::Matrix<double, -1, -1>(nevent, ncurecovs);
      stan::math::fill(xcure_event, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> xcure_event_flat__;
        current_statement__ = 200;
        assign(xcure_event_flat__, nil_index_list(),
          context__.vals_r("xcure_event"),
          "assigning variable xcure_event_flat__");
        current_statement__ = 200;
        pos__ = 1;
        current_statement__ = 200;
        for (int sym1__ = 1; sym1__ <= ncurecovs; ++sym1__) {
          current_statement__ = 200;
          for (int sym2__ = 1; sym2__ <= nevent; ++sym2__) {
            current_statement__ = 200;
            assign(xcure_event,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              xcure_event_flat__[(pos__ - 1)],
              "assigning variable xcure_event");
            current_statement__ = 200;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 201;
      validate_non_negative_index("xcure_rcens", "nrcens", nrcens);
      current_statement__ = 202;
      validate_non_negative_index("xcure_rcens", "ncurecovs", ncurecovs);
      current_statement__ = 203;
      context__.validate_dims("data initialization","xcure_rcens","double",
          context__.to_vec(nrcens, ncurecovs));
      xcure_rcens = Eigen::Matrix<double, -1, -1>(nrcens, ncurecovs);
      stan::math::fill(xcure_rcens, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> xcure_rcens_flat__;
        current_statement__ = 203;
        assign(xcure_rcens_flat__, nil_index_list(),
          context__.vals_r("xcure_rcens"),
          "assigning variable xcure_rcens_flat__");
        current_statement__ = 203;
        pos__ = 1;
        current_statement__ = 203;
        for (int sym1__ = 1; sym1__ <= ncurecovs; ++sym1__) {
          current_statement__ = 203;
          for (int sym2__ = 1; sym2__ <= nrcens; ++sym2__) {
            current_statement__ = 203;
            assign(xcure_rcens,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              xcure_rcens_flat__[(pos__ - 1)],
              "assigning variable xcure_rcens");
            current_statement__ = 203;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 204;
      validate_non_negative_index("r_ext", "nextern", nextern);
      current_statement__ = 205;
      context__.validate_dims("data initialization","r_ext","int",
          context__.to_vec(nextern));
      r_ext = std::vector<int>(nextern, std::numeric_limits<int>::min());
      
      current_statement__ = 205;
      assign(r_ext, nil_index_list(), context__.vals_i("r_ext"),
        "assigning variable r_ext");
      current_statement__ = 205;
      for (int sym1__ = 1; sym1__ <= nextern; ++sym1__) {
        current_statement__ = 205;
        current_statement__ = 205;
        check_greater_or_equal(function__, "r_ext[sym1__]",
                               r_ext[(sym1__ - 1)], 0);}
      current_statement__ = 206;
      validate_non_negative_index("n_ext", "nextern", nextern);
      current_statement__ = 207;
      context__.validate_dims("data initialization","n_ext","int",
          context__.to_vec(nextern));
      n_ext = std::vector<int>(nextern, std::numeric_limits<int>::min());
      
      current_statement__ = 207;
      assign(n_ext, nil_index_list(), context__.vals_i("n_ext"),
        "assigning variable n_ext");
      current_statement__ = 207;
      for (int sym1__ = 1; sym1__ <= nextern; ++sym1__) {
        current_statement__ = 207;
        current_statement__ = 207;
        check_greater_or_equal(function__, "n_ext[sym1__]",
                               n_ext[(sym1__ - 1)], 0);}
      current_statement__ = 208;
      validate_non_negative_index("x_ext", "nextern", nextern);
      current_statement__ = 209;
      validate_non_negative_index("x_ext", "ncovs", ncovs);
      current_statement__ = 210;
      context__.validate_dims("data initialization","x_ext","double",
          context__.to_vec(nextern, ncovs));
      x_ext = Eigen::Matrix<double, -1, -1>(nextern, ncovs);
      stan::math::fill(x_ext, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> x_ext_flat__;
        current_statement__ = 210;
        assign(x_ext_flat__, nil_index_list(), context__.vals_r("x_ext"),
          "assigning variable x_ext_flat__");
        current_statement__ = 210;
        pos__ = 1;
        current_statement__ = 210;
        for (int sym1__ = 1; sym1__ <= ncovs; ++sym1__) {
          current_statement__ = 210;
          for (int sym2__ = 1; sym2__ <= nextern; ++sym2__) {
            current_statement__ = 210;
            assign(x_ext,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              x_ext_flat__[(pos__ - 1)], "assigning variable x_ext");
            current_statement__ = 210;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 211;
      validate_non_negative_index("xcure_ext", "nextern", nextern);
      current_statement__ = 212;
      validate_non_negative_index("xcure_ext", "ncurecovs", ncurecovs);
      current_statement__ = 213;
      context__.validate_dims("data initialization","xcure_ext","double",
          context__.to_vec(nextern, ncurecovs));
      xcure_ext = Eigen::Matrix<double, -1, -1>(nextern, ncurecovs);
      stan::math::fill(xcure_ext, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> xcure_ext_flat__;
        current_statement__ = 213;
        assign(xcure_ext_flat__, nil_index_list(),
          context__.vals_r("xcure_ext"),
          "assigning variable xcure_ext_flat__");
        current_statement__ = 213;
        pos__ = 1;
        current_statement__ = 213;
        for (int sym1__ = 1; sym1__ <= ncurecovs; ++sym1__) {
          current_statement__ = 213;
          for (int sym2__ = 1; sym2__ <= nextern; ++sym2__) {
            current_statement__ = 213;
            assign(xcure_ext,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              xcure_ext_flat__[(pos__ - 1)], "assigning variable xcure_ext");
            current_statement__ = 213;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 214;
      validate_non_negative_index("b_mean", "nvars - 1", (nvars - 1));
      current_statement__ = 215;
      context__.validate_dims("data initialization","b_mean","double",
          context__.to_vec((nvars - 1)));
      b_mean = Eigen::Matrix<double, -1, 1>((nvars - 1));
      stan::math::fill(b_mean, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> b_mean_flat__;
        current_statement__ = 215;
        assign(b_mean_flat__, nil_index_list(), context__.vals_r("b_mean"),
          "assigning variable b_mean_flat__");
        current_statement__ = 215;
        pos__ = 1;
        current_statement__ = 215;
        for (int sym1__ = 1; sym1__ <= (nvars - 1); ++sym1__) {
          current_statement__ = 215;
          assign(b_mean, cons_list(index_uni(sym1__), nil_index_list()),
            b_mean_flat__[(pos__ - 1)], "assigning variable b_mean");
          current_statement__ = 215;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 216;
      context__.validate_dims("data initialization","est_hsd","int",
          context__.to_vec());
      est_hsd = std::numeric_limits<int>::min();
      
      current_statement__ = 216;
      est_hsd = context__.vals_i("est_hsd")[(1 - 1)];
      current_statement__ = 217;
      validate_non_negative_index("hsd_fixed", "1 - est_hsd", (1 - est_hsd));
      current_statement__ = 218;
      context__.validate_dims("data initialization","hsd_fixed","double",
          context__.to_vec((1 - est_hsd)));
      hsd_fixed = Eigen::Matrix<double, -1, 1>((1 - est_hsd));
      stan::math::fill(hsd_fixed, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> hsd_fixed_flat__;
        current_statement__ = 218;
        assign(hsd_fixed_flat__, nil_index_list(),
          context__.vals_r("hsd_fixed"),
          "assigning variable hsd_fixed_flat__");
        current_statement__ = 218;
        pos__ = 1;
        current_statement__ = 218;
        for (int sym1__ = 1; sym1__ <= (1 - est_hsd); ++sym1__) {
          current_statement__ = 218;
          assign(hsd_fixed, cons_list(index_uni(sym1__), nil_index_list()),
            hsd_fixed_flat__[(pos__ - 1)], "assigning variable hsd_fixed");
          current_statement__ = 218;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 218;
      for (int sym1__ = 1; sym1__ <= (1 - est_hsd); ++sym1__) {
        current_statement__ = 218;
        current_statement__ = 218;
        check_greater_or_equal(function__, "hsd_fixed[sym1__]",
                               hsd_fixed[(sym1__ - 1)], 0);}
      current_statement__ = 219;
      context__.validate_dims("data initialization","cure","int",
          context__.to_vec());
      cure = std::numeric_limits<int>::min();
      
      current_statement__ = 219;
      cure = context__.vals_i("cure")[(1 - 1)];
      current_statement__ = 220;
      context__.validate_dims("data initialization","relative","int",
          context__.to_vec());
      relative = std::numeric_limits<int>::min();
      
      current_statement__ = 220;
      relative = context__.vals_i("relative")[(1 - 1)];
      current_statement__ = 221;
      validate_non_negative_index("backhaz_event", "nevent", nevent);
      current_statement__ = 222;
      context__.validate_dims("data initialization","backhaz_event","double",
          context__.to_vec(nevent));
      backhaz_event = Eigen::Matrix<double, -1, 1>(nevent);
      stan::math::fill(backhaz_event, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> backhaz_event_flat__;
        current_statement__ = 222;
        assign(backhaz_event_flat__, nil_index_list(),
          context__.vals_r("backhaz_event"),
          "assigning variable backhaz_event_flat__");
        current_statement__ = 222;
        pos__ = 1;
        current_statement__ = 222;
        for (int sym1__ = 1; sym1__ <= nevent; ++sym1__) {
          current_statement__ = 222;
          assign(backhaz_event,
            cons_list(index_uni(sym1__), nil_index_list()),
            backhaz_event_flat__[(pos__ - 1)],
            "assigning variable backhaz_event");
          current_statement__ = 222;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 223;
      validate_non_negative_index("backsurv_ext_start", "nextern", nextern);
      current_statement__ = 224;
      context__.validate_dims("data initialization","backsurv_ext_start",
          "double",context__.to_vec(nextern));
      backsurv_ext_start = Eigen::Matrix<double, -1, 1>(nextern);
      stan::math::fill(backsurv_ext_start, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> backsurv_ext_start_flat__;
        current_statement__ = 224;
        assign(backsurv_ext_start_flat__, nil_index_list(),
          context__.vals_r("backsurv_ext_start"),
          "assigning variable backsurv_ext_start_flat__");
        current_statement__ = 224;
        pos__ = 1;
        current_statement__ = 224;
        for (int sym1__ = 1; sym1__ <= nextern; ++sym1__) {
          current_statement__ = 224;
          assign(backsurv_ext_start,
            cons_list(index_uni(sym1__), nil_index_list()),
            backsurv_ext_start_flat__[(pos__ - 1)],
            "assigning variable backsurv_ext_start");
          current_statement__ = 224;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 225;
      validate_non_negative_index("backsurv_ext_stop", "nextern", nextern);
      current_statement__ = 226;
      context__.validate_dims("data initialization","backsurv_ext_stop",
          "double",context__.to_vec(nextern));
      backsurv_ext_stop = Eigen::Matrix<double, -1, 1>(nextern);
      stan::math::fill(backsurv_ext_stop, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> backsurv_ext_stop_flat__;
        current_statement__ = 226;
        assign(backsurv_ext_stop_flat__, nil_index_list(),
          context__.vals_r("backsurv_ext_stop"),
          "assigning variable backsurv_ext_stop_flat__");
        current_statement__ = 226;
        pos__ = 1;
        current_statement__ = 226;
        for (int sym1__ = 1; sym1__ <= nextern; ++sym1__) {
          current_statement__ = 226;
          assign(backsurv_ext_stop,
            cons_list(index_uni(sym1__), nil_index_list()),
            backsurv_ext_stop_flat__[(pos__ - 1)],
            "assigning variable backsurv_ext_stop");
          current_statement__ = 226;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 227;
      context__.validate_dims("data initialization","prior_hscale_dist",
          "int",context__.to_vec());
      prior_hscale_dist = std::numeric_limits<int>::min();
      
      current_statement__ = 227;
      prior_hscale_dist = context__.vals_i("prior_hscale_dist")[(1 - 1)];
      current_statement__ = 228;
      context__.validate_dims("data initialization","prior_hscale","double",
          context__.to_vec(3));
      prior_hscale = Eigen::Matrix<double, -1, 1>(3);
      stan::math::fill(prior_hscale, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> prior_hscale_flat__;
        current_statement__ = 228;
        assign(prior_hscale_flat__, nil_index_list(),
          context__.vals_r("prior_hscale"),
          "assigning variable prior_hscale_flat__");
        current_statement__ = 228;
        pos__ = 1;
        current_statement__ = 228;
        for (int sym1__ = 1; sym1__ <= 3; ++sym1__) {
          current_statement__ = 228;
          assign(prior_hscale,
            cons_list(index_uni(sym1__), nil_index_list()),
            prior_hscale_flat__[(pos__ - 1)],
            "assigning variable prior_hscale");
          current_statement__ = 228;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 229;
      context__.validate_dims("data initialization","prior_cure","double",
          context__.to_vec(2));
      prior_cure = Eigen::Matrix<double, -1, 1>(2);
      stan::math::fill(prior_cure, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> prior_cure_flat__;
        current_statement__ = 229;
        assign(prior_cure_flat__, nil_index_list(),
          context__.vals_r("prior_cure"),
          "assigning variable prior_cure_flat__");
        current_statement__ = 229;
        pos__ = 1;
        current_statement__ = 229;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 229;
          assign(prior_cure, cons_list(index_uni(sym1__), nil_index_list()),
            prior_cure_flat__[(pos__ - 1)], "assigning variable prior_cure");
          current_statement__ = 229;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 229;
      for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
        current_statement__ = 229;
        current_statement__ = 229;
        check_greater_or_equal(function__, "prior_cure[sym1__]",
                               prior_cure[(sym1__ - 1)], 0);}
      current_statement__ = 230;
      validate_non_negative_index("prior_hsd", "2 * est_hsd", (2 * est_hsd));
      current_statement__ = 231;
      context__.validate_dims("data initialization","prior_hsd","double",
          context__.to_vec((2 * est_hsd)));
      prior_hsd = Eigen::Matrix<double, -1, 1>((2 * est_hsd));
      stan::math::fill(prior_hsd, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> prior_hsd_flat__;
        current_statement__ = 231;
        assign(prior_hsd_flat__, nil_index_list(),
          context__.vals_r("prior_hsd"),
          "assigning variable prior_hsd_flat__");
        current_statement__ = 231;
        pos__ = 1;
        current_statement__ = 231;
        for (int sym1__ = 1; sym1__ <= (2 * est_hsd); ++sym1__) {
          current_statement__ = 231;
          assign(prior_hsd, cons_list(index_uni(sym1__), nil_index_list()),
            prior_hsd_flat__[(pos__ - 1)], "assigning variable prior_hsd");
          current_statement__ = 231;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 231;
      for (int sym1__ = 1; sym1__ <= (2 * est_hsd); ++sym1__) {
        current_statement__ = 231;
        current_statement__ = 231;
        check_greater_or_equal(function__, "prior_hsd[sym1__]",
                               prior_hsd[(sym1__ - 1)], 0);}
      current_statement__ = 232;
      validate_non_negative_index("prior_loghr_dist", "ncovs", ncovs);
      current_statement__ = 233;
      context__.validate_dims("data initialization","prior_loghr_dist","int",
          context__.to_vec(ncovs));
      prior_loghr_dist = std::vector<int>(ncovs, std::numeric_limits<int>::min());
      
      current_statement__ = 233;
      assign(prior_loghr_dist, nil_index_list(),
        context__.vals_i("prior_loghr_dist"),
        "assigning variable prior_loghr_dist");
      current_statement__ = 233;
      for (int sym1__ = 1; sym1__ <= ncovs; ++sym1__) {
        current_statement__ = 233;
        current_statement__ = 233;
        check_greater_or_equal(function__, "prior_loghr_dist[sym1__]",
                               prior_loghr_dist[(sym1__ - 1)], 0);}
      current_statement__ = 234;
      validate_non_negative_index("prior_loghr_location", "ncovs", ncovs);
      current_statement__ = 235;
      context__.validate_dims("data initialization","prior_loghr_location",
          "double",context__.to_vec(ncovs));
      prior_loghr_location = Eigen::Matrix<double, -1, 1>(ncovs);
      stan::math::fill(prior_loghr_location, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> prior_loghr_location_flat__;
        current_statement__ = 235;
        assign(prior_loghr_location_flat__, nil_index_list(),
          context__.vals_r("prior_loghr_location"),
          "assigning variable prior_loghr_location_flat__");
        current_statement__ = 235;
        pos__ = 1;
        current_statement__ = 235;
        for (int sym1__ = 1; sym1__ <= ncovs; ++sym1__) {
          current_statement__ = 235;
          assign(prior_loghr_location,
            cons_list(index_uni(sym1__), nil_index_list()),
            prior_loghr_location_flat__[(pos__ - 1)],
            "assigning variable prior_loghr_location");
          current_statement__ = 235;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 236;
      validate_non_negative_index("prior_loghr_scale", "ncovs", ncovs);
      current_statement__ = 237;
      context__.validate_dims("data initialization","prior_loghr_scale",
          "double",context__.to_vec(ncovs));
      prior_loghr_scale = Eigen::Matrix<double, -1, 1>(ncovs);
      stan::math::fill(prior_loghr_scale, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> prior_loghr_scale_flat__;
        current_statement__ = 237;
        assign(prior_loghr_scale_flat__, nil_index_list(),
          context__.vals_r("prior_loghr_scale"),
          "assigning variable prior_loghr_scale_flat__");
        current_statement__ = 237;
        pos__ = 1;
        current_statement__ = 237;
        for (int sym1__ = 1; sym1__ <= ncovs; ++sym1__) {
          current_statement__ = 237;
          assign(prior_loghr_scale,
            cons_list(index_uni(sym1__), nil_index_list()),
            prior_loghr_scale_flat__[(pos__ - 1)],
            "assigning variable prior_loghr_scale");
          current_statement__ = 237;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 238;
      validate_non_negative_index("prior_loghr_df", "ncovs", ncovs);
      current_statement__ = 239;
      context__.validate_dims("data initialization","prior_loghr_df",
          "double",context__.to_vec(ncovs));
      prior_loghr_df = Eigen::Matrix<double, -1, 1>(ncovs);
      stan::math::fill(prior_loghr_df, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> prior_loghr_df_flat__;
        current_statement__ = 239;
        assign(prior_loghr_df_flat__, nil_index_list(),
          context__.vals_r("prior_loghr_df"),
          "assigning variable prior_loghr_df_flat__");
        current_statement__ = 239;
        pos__ = 1;
        current_statement__ = 239;
        for (int sym1__ = 1; sym1__ <= ncovs; ++sym1__) {
          current_statement__ = 239;
          assign(prior_loghr_df,
            cons_list(index_uni(sym1__), nil_index_list()),
            prior_loghr_df_flat__[(pos__ - 1)],
            "assigning variable prior_loghr_df");
          current_statement__ = 239;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 240;
      validate_non_negative_index("prior_logor_cure_dist", "ncurecovs",
                                  ncurecovs);
      current_statement__ = 241;
      context__.validate_dims("data initialization","prior_logor_cure_dist",
          "int",context__.to_vec(ncurecovs));
      prior_logor_cure_dist = std::vector<int>(ncurecovs, std::numeric_limits<int>::min());
      
      current_statement__ = 241;
      assign(prior_logor_cure_dist, nil_index_list(),
        context__.vals_i("prior_logor_cure_dist"),
        "assigning variable prior_logor_cure_dist");
      current_statement__ = 241;
      for (int sym1__ = 1; sym1__ <= ncurecovs; ++sym1__) {
        current_statement__ = 241;
        current_statement__ = 241;
        check_greater_or_equal(function__, "prior_logor_cure_dist[sym1__]",
                               prior_logor_cure_dist[(sym1__ - 1)], 0);}
      current_statement__ = 242;
      validate_non_negative_index("prior_logor_cure_location", "ncurecovs",
                                  ncurecovs);
      current_statement__ = 243;
      context__.validate_dims("data initialization",
          "prior_logor_cure_location","double",context__.to_vec(ncurecovs));
      prior_logor_cure_location = Eigen::Matrix<double, -1, 1>(ncurecovs);
      stan::math::fill(prior_logor_cure_location, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> prior_logor_cure_location_flat__;
        current_statement__ = 243;
        assign(prior_logor_cure_location_flat__, nil_index_list(),
          context__.vals_r("prior_logor_cure_location"),
          "assigning variable prior_logor_cure_location_flat__");
        current_statement__ = 243;
        pos__ = 1;
        current_statement__ = 243;
        for (int sym1__ = 1; sym1__ <= ncurecovs; ++sym1__) {
          current_statement__ = 243;
          assign(prior_logor_cure_location,
            cons_list(index_uni(sym1__), nil_index_list()),
            prior_logor_cure_location_flat__[(pos__ - 1)],
            "assigning variable prior_logor_cure_location");
          current_statement__ = 243;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 244;
      validate_non_negative_index("prior_logor_cure_scale", "ncurecovs",
                                  ncurecovs);
      current_statement__ = 245;
      context__.validate_dims("data initialization","prior_logor_cure_scale",
          "double",context__.to_vec(ncurecovs));
      prior_logor_cure_scale = Eigen::Matrix<double, -1, 1>(ncurecovs);
      stan::math::fill(prior_logor_cure_scale, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> prior_logor_cure_scale_flat__;
        current_statement__ = 245;
        assign(prior_logor_cure_scale_flat__, nil_index_list(),
          context__.vals_r("prior_logor_cure_scale"),
          "assigning variable prior_logor_cure_scale_flat__");
        current_statement__ = 245;
        pos__ = 1;
        current_statement__ = 245;
        for (int sym1__ = 1; sym1__ <= ncurecovs; ++sym1__) {
          current_statement__ = 245;
          assign(prior_logor_cure_scale,
            cons_list(index_uni(sym1__), nil_index_list()),
            prior_logor_cure_scale_flat__[(pos__ - 1)],
            "assigning variable prior_logor_cure_scale");
          current_statement__ = 245;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 246;
      validate_non_negative_index("prior_logor_cure_df", "ncurecovs",
                                  ncurecovs);
      current_statement__ = 247;
      context__.validate_dims("data initialization","prior_logor_cure_df",
          "double",context__.to_vec(ncurecovs));
      prior_logor_cure_df = Eigen::Matrix<double, -1, 1>(ncurecovs);
      stan::math::fill(prior_logor_cure_df, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> prior_logor_cure_df_flat__;
        current_statement__ = 247;
        assign(prior_logor_cure_df_flat__, nil_index_list(),
          context__.vals_r("prior_logor_cure_df"),
          "assigning variable prior_logor_cure_df_flat__");
        current_statement__ = 247;
        pos__ = 1;
        current_statement__ = 247;
        for (int sym1__ = 1; sym1__ <= ncurecovs; ++sym1__) {
          current_statement__ = 247;
          assign(prior_logor_cure_df,
            cons_list(index_uni(sym1__), nil_index_list()),
            prior_logor_cure_df_flat__[(pos__ - 1)],
            "assigning variable prior_logor_cure_df");
          current_statement__ = 247;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 248;
      context__.validate_dims("data initialization","modelid","int",
          context__.to_vec());
      modelid = std::numeric_limits<int>::min();
      
      current_statement__ = 248;
      modelid = context__.vals_i("modelid")[(1 - 1)];
      current_statement__ = 249;
      context__.validate_dims("data initialization","nonprop","int",
          context__.to_vec());
      nonprop = std::numeric_limits<int>::min();
      
      current_statement__ = 249;
      nonprop = context__.vals_i("nonprop")[(1 - 1)];
      current_statement__ = 250;
      validate_non_negative_index("prior_hrsd", "ncovs * nonprop",
                                  (ncovs * nonprop));
      current_statement__ = 251;
      context__.validate_dims("data initialization","prior_hrsd","double",
          context__.to_vec((ncovs * nonprop), 2));
      prior_hrsd = Eigen::Matrix<double, -1, -1>((ncovs * nonprop), 2);
      stan::math::fill(prior_hrsd, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> prior_hrsd_flat__;
        current_statement__ = 251;
        assign(prior_hrsd_flat__, nil_index_list(),
          context__.vals_r("prior_hrsd"),
          "assigning variable prior_hrsd_flat__");
        current_statement__ = 251;
        pos__ = 1;
        current_statement__ = 251;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 251;
          for (int sym2__ = 1; sym2__ <= (ncovs * nonprop); ++sym2__) {
            current_statement__ = 251;
            assign(prior_hrsd,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              prior_hrsd_flat__[(pos__ - 1)], "assigning variable prior_hrsd");
            current_statement__ = 251;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 252;
      validate_non_negative_index("gamma", "1", 1);
      current_statement__ = 253;
      validate_non_negative_index("loghr", "ncovs", ncovs);
      current_statement__ = 254;
      b_err_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 254;
      b_err_1dim__ = (nvars - 1);
      current_statement__ = 254;
      validate_non_negative_index("b_err", "nvars - 1", b_err_1dim__);
      current_statement__ = 255;
      validate_non_negative_index("hsd", "est_hsd", est_hsd);
      current_statement__ = 256;
      validate_non_negative_index("pcure", "cure", cure);
      current_statement__ = 257;
      validate_non_negative_index("logor_cure", "ncurecovs", ncurecovs);
      current_statement__ = 258;
      hrsd_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 258;
      hrsd_1dim__ = (ncovs * nonprop);
      current_statement__ = 258;
      validate_non_negative_index("hrsd", "ncovs * nonprop", hrsd_1dim__);
      current_statement__ = 259;
      nperr_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 259;
      nperr_1dim__ = (ncovs * nonprop);
      current_statement__ = 259;
      validate_non_negative_index("nperr", "ncovs * nonprop", nperr_1dim__);
      current_statement__ = 260;
      nperr_2dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 260;
      nperr_2dim__ = (nvars - 1);
      current_statement__ = 260;
      validate_non_negative_index("nperr", "nvars - 1", nperr_2dim__);
      current_statement__ = 261;
      validate_non_negative_index("b", "nvars", nvars);
      current_statement__ = 262;
      validate_non_negative_index("coefs", "nvars", nvars);
      current_statement__ = 263;
      validate_non_negative_index("coefs_event", "nevent", nevent);
      current_statement__ = 264;
      validate_non_negative_index("coefs_event", "nvars", nvars);
      current_statement__ = 265;
      validate_non_negative_index("coefs_rcens", "nrcens", nrcens);
      current_statement__ = 266;
      validate_non_negative_index("coefs_rcens", "nvars", nvars);
      current_statement__ = 267;
      validate_non_negative_index("coefs_extern", "nextern", nextern);
      current_statement__ = 268;
      validate_non_negative_index("coefs_extern", "nvars", nvars);
      current_statement__ = 269;
      validate_non_negative_index("b_event", "nevent", nevent);
      current_statement__ = 270;
      validate_non_negative_index("b_event", "nvars", nvars);
      current_statement__ = 271;
      validate_non_negative_index("b_rcens", "nrcens", nrcens);
      current_statement__ = 272;
      validate_non_negative_index("b_rcens", "nvars", nvars);
      current_statement__ = 273;
      validate_non_negative_index("b_extern", "nextern", nextern);
      current_statement__ = 274;
      validate_non_negative_index("b_extern", "nvars", nvars);
      current_statement__ = 275;
      validate_non_negative_index("b_np", "ncovs", ncovs);
      current_statement__ = 276;
      b_np_2dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 276;
      b_np_2dim__ = (nvars - 1);
      current_statement__ = 276;
      validate_non_negative_index("b_np", "nvars - 1", b_np_2dim__);
      current_statement__ = 277;
      validate_non_negative_index("hr", "ncovs", ncovs);
      current_statement__ = 278;
      validate_non_negative_index("or_cure", "ncurecovs", ncurecovs);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += 1;
      num_params_r__ += ncovs;
      num_params_r__ += b_err_1dim__;
      num_params_r__ += est_hsd;
      num_params_r__ += cure;
      num_params_r__ += ncurecovs;
      num_params_r__ += hrsd_1dim__;
      num_params_r__ += nperr_1dim__ * nperr_2dim__;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename VecR, typename VecI, stan::require_vector_like_t<VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "model_survextrap_namespace::log_prob";
(void) function__;  // suppress unused var warning
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      std::vector<local_scalar_t__> gamma;
      gamma = std::vector<local_scalar_t__>(1, DUMMY_VAR__);
      
      current_statement__ = 1;
      for (int sym1__ = 1; sym1__ <= 1; ++sym1__) {
        current_statement__ = 1;
        assign(gamma, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable gamma");}
      Eigen::Matrix<local_scalar_t__, -1, 1> loghr;
      loghr = Eigen::Matrix<local_scalar_t__, -1, 1>(ncovs);
      stan::math::fill(loghr, DUMMY_VAR__);
      
      current_statement__ = 2;
      loghr = in__.vector(ncovs);
      Eigen::Matrix<local_scalar_t__, -1, 1> b_err;
      b_err = Eigen::Matrix<local_scalar_t__, -1, 1>(b_err_1dim__);
      stan::math::fill(b_err, DUMMY_VAR__);
      
      current_statement__ = 3;
      b_err = in__.vector(b_err_1dim__);
      Eigen::Matrix<local_scalar_t__, -1, 1> hsd;
      hsd = Eigen::Matrix<local_scalar_t__, -1, 1>(est_hsd);
      stan::math::fill(hsd, DUMMY_VAR__);
      
      current_statement__ = 4;
      hsd = in__.vector(est_hsd);
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= est_hsd; ++sym1__) {
        current_statement__ = 4;
        if (jacobian__) {
          current_statement__ = 4;
          assign(hsd, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(hsd[(sym1__ - 1)], 0, lp__),
            "assigning variable hsd");
        } else {
          current_statement__ = 4;
          assign(hsd, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(hsd[(sym1__ - 1)], 0),
            "assigning variable hsd");
        }}
      Eigen::Matrix<local_scalar_t__, -1, 1> pcure;
      pcure = Eigen::Matrix<local_scalar_t__, -1, 1>(cure);
      stan::math::fill(pcure, DUMMY_VAR__);
      
      current_statement__ = 5;
      pcure = in__.vector(cure);
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= cure; ++sym1__) {
        current_statement__ = 5;
        if (jacobian__) {
          current_statement__ = 5;
          assign(pcure, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lub_constrain(pcure[(sym1__ - 1)], 0, 1, lp__),
            "assigning variable pcure");
        } else {
          current_statement__ = 5;
          assign(pcure, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lub_constrain(pcure[(sym1__ - 1)], 0, 1),
            "assigning variable pcure");
        }}
      Eigen::Matrix<local_scalar_t__, -1, 1> logor_cure;
      logor_cure = Eigen::Matrix<local_scalar_t__, -1, 1>(ncurecovs);
      stan::math::fill(logor_cure, DUMMY_VAR__);
      
      current_statement__ = 6;
      logor_cure = in__.vector(ncurecovs);
      Eigen::Matrix<local_scalar_t__, -1, 1> hrsd;
      hrsd = Eigen::Matrix<local_scalar_t__, -1, 1>(hrsd_1dim__);
      stan::math::fill(hrsd, DUMMY_VAR__);
      
      current_statement__ = 7;
      hrsd = in__.vector(hrsd_1dim__);
      current_statement__ = 7;
      for (int sym1__ = 1; sym1__ <= hrsd_1dim__; ++sym1__) {
        current_statement__ = 7;
        if (jacobian__) {
          current_statement__ = 7;
          assign(hrsd, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(hrsd[(sym1__ - 1)], 0, lp__),
            "assigning variable hrsd");
        } else {
          current_statement__ = 7;
          assign(hrsd, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(hrsd[(sym1__ - 1)], 0),
            "assigning variable hrsd");
        }}
      Eigen::Matrix<local_scalar_t__, -1, -1> nperr;
      nperr = Eigen::Matrix<local_scalar_t__, -1, -1>(nperr_1dim__, nperr_2dim__);
      stan::math::fill(nperr, DUMMY_VAR__);
      
      current_statement__ = 8;
      nperr = in__.matrix(nperr_1dim__, nperr_2dim__);
      Eigen::Matrix<local_scalar_t__, -1, 1> b;
      b = Eigen::Matrix<local_scalar_t__, -1, 1>(nvars);
      stan::math::fill(b, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, 1> coefs;
      coefs = Eigen::Matrix<local_scalar_t__, -1, 1>(nvars);
      stan::math::fill(coefs, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> coefs_event;
      coefs_event = Eigen::Matrix<local_scalar_t__, -1, -1>(nevent, nvars);
      stan::math::fill(coefs_event, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> coefs_rcens;
      coefs_rcens = Eigen::Matrix<local_scalar_t__, -1, -1>(nrcens, nvars);
      stan::math::fill(coefs_rcens, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> coefs_extern;
      coefs_extern = Eigen::Matrix<local_scalar_t__, -1, -1>(nextern, nvars);
      stan::math::fill(coefs_extern, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> b_event;
      b_event = Eigen::Matrix<local_scalar_t__, -1, -1>(nevent, nvars);
      stan::math::fill(b_event, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> b_rcens;
      b_rcens = Eigen::Matrix<local_scalar_t__, -1, -1>(nrcens, nvars);
      stan::math::fill(b_rcens, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> b_extern;
      b_extern = Eigen::Matrix<local_scalar_t__, -1, -1>(nextern, nvars);
      stan::math::fill(b_extern, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> b_np;
      b_np = Eigen::Matrix<local_scalar_t__, -1, -1>(ncovs, b_np_2dim__);
      stan::math::fill(b_np, DUMMY_VAR__);
      
      local_scalar_t__ ssd;
      ssd = DUMMY_VAR__;
      
      current_statement__ = 94;
      if ((primitive_value(logical_gt(ncovs, 0)) && primitive_value(nonprop))) {
        current_statement__ = 58;
        for (int r = 1; r <= ncovs; ++r) {
          current_statement__ = 56;
          assign(b_np,
            cons_list(index_uni(r),
              cons_list(index_min_max(1, (nvars - 1)), nil_index_list())),
            multiply(hrsd[(r - 1)],
              rvalue(nperr,
                cons_list(index_uni(r),
                  cons_list(index_min_max(1, (nvars - 1)), nil_index_list())),
                "nperr")), "assigning variable b_np");}
        current_statement__ = 63;
        if (est_hsd) {
          current_statement__ = 61;
          ssd = hsd[(1 - 1)];
        } else {
          current_statement__ = 59;
          ssd = hsd_fixed[(1 - 1)];
        }
        current_statement__ = 64;
        assign(b, nil_index_list(),
          append_row(0, add(b_mean, multiply(b_err, ssd))),
          "assigning variable b");
        current_statement__ = 65;
        assign(coefs, nil_index_list(), softmax(b),
          "assigning variable coefs");
        current_statement__ = 74;
        if (logical_gt(nevent, 0)) {
          current_statement__ = 66;
          assign(b_event,
            cons_list(index_min_max(1, nevent),
              cons_list(index_uni(1), nil_index_list())),
            rep_vector(0, nevent), "assigning variable b_event");
          current_statement__ = 69;
          for (int j = 1; j <= (nvars - 1); ++j) {
            current_statement__ = 67;
            assign(b_event,
              cons_list(index_min_max(1, nevent),
                cons_list(index_uni((j + 1)), nil_index_list())),
              add(
                add(b_mean[(j - 1)],
                  multiply(x_event,
                    rvalue(b_np,
                      cons_list(index_omni(),
                        cons_list(index_uni(j), nil_index_list())), "b_np"))),
                (b_err[(j - 1)] * ssd)), "assigning variable b_event");}
          current_statement__ = 72;
          for (int i = 1; i <= nevent; ++i) {
            current_statement__ = 70;
            assign(coefs_event,
              cons_list(index_uni(i),
                cons_list(index_min_max(1, nvars), nil_index_list())),
              to_row_vector(
                softmax(
                  to_vector(
                    rvalue(b_event,
                      cons_list(index_uni(i),
                        cons_list(index_min_max(1, nvars), nil_index_list())),
                      "b_event")))), "assigning variable coefs_event");}
        } 
        current_statement__ = 83;
        if (logical_gt(nrcens, 0)) {
          current_statement__ = 75;
          assign(b_rcens,
            cons_list(index_min_max(1, nrcens),
              cons_list(index_uni(1), nil_index_list())),
            rep_vector(0, nrcens), "assigning variable b_rcens");
          current_statement__ = 78;
          for (int j = 1; j <= (nvars - 1); ++j) {
            current_statement__ = 76;
            assign(b_rcens,
              cons_list(index_min_max(1, nrcens),
                cons_list(index_uni((j + 1)), nil_index_list())),
              add(
                add(b_mean[(j - 1)],
                  multiply(x_rcens,
                    rvalue(b_np,
                      cons_list(index_omni(),
                        cons_list(index_uni(j), nil_index_list())), "b_np"))),
                (b_err[(j - 1)] * ssd)), "assigning variable b_rcens");}
          current_statement__ = 81;
          for (int i = 1; i <= nrcens; ++i) {
            current_statement__ = 79;
            assign(coefs_rcens,
              cons_list(index_uni(i),
                cons_list(index_min_max(1, nvars), nil_index_list())),
              to_row_vector(
                softmax(
                  to_vector(
                    rvalue(b_rcens,
                      cons_list(index_uni(i),
                        cons_list(index_min_max(1, nvars), nil_index_list())),
                      "b_rcens")))), "assigning variable coefs_rcens");}
        } 
        current_statement__ = 92;
        if (logical_gt(nextern, 0)) {
          current_statement__ = 84;
          assign(b_extern,
            cons_list(index_min_max(1, nextern),
              cons_list(index_uni(1), nil_index_list())),
            rep_vector(0, nextern), "assigning variable b_extern");
          current_statement__ = 87;
          for (int j = 1; j <= (nvars - 1); ++j) {
            current_statement__ = 85;
            assign(b_extern,
              cons_list(index_min_max(1, nextern),
                cons_list(index_uni((j + 1)), nil_index_list())),
              add(
                add(b_mean[(j - 1)],
                  multiply(x_ext,
                    rvalue(b_np,
                      cons_list(index_omni(),
                        cons_list(index_uni(j), nil_index_list())), "b_np"))),
                (b_err[(j - 1)] * ssd)), "assigning variable b_extern");}
          current_statement__ = 90;
          for (int i = 1; i <= nextern; ++i) {
            current_statement__ = 88;
            assign(coefs_extern,
              cons_list(index_uni(i),
                cons_list(index_min_max(1, nvars), nil_index_list())),
              to_row_vector(
                softmax(
                  to_vector(
                    rvalue(b_extern,
                      cons_list(index_uni(i),
                        cons_list(index_min_max(1, nvars), nil_index_list())),
                      "b_extern")))), "assigning variable coefs_extern");}
        } 
      } else {
        current_statement__ = 21;
        if (est_hsd) {
          current_statement__ = 20;
          assign(b, nil_index_list(),
            append_row(0, add(b_mean, multiply(b_err, hsd[(1 - 1)]))),
            "assigning variable b");
        } else {
          current_statement__ = 19;
          assign(b, nil_index_list(),
            append_row(0, add(b_mean, multiply(b_err, hsd_fixed[(1 - 1)]))),
            "assigning variable b");
        }
        current_statement__ = 22;
        assign(coefs, nil_index_list(), softmax(b),
          "assigning variable coefs");
        current_statement__ = 27;
        if (logical_gt(nevent, 0)) {
          current_statement__ = 25;
          for (int i = 1; i <= nevent; ++i) {
            current_statement__ = 23;
            assign(coefs_event,
              cons_list(index_uni(i),
                cons_list(index_min_max(1, nvars), nil_index_list())),
              to_row_vector(coefs), "assigning variable coefs_event");}
        } 
        current_statement__ = 32;
        if (logical_gt(nrcens, 0)) {
          current_statement__ = 30;
          for (int i = 1; i <= nrcens; ++i) {
            current_statement__ = 28;
            assign(coefs_rcens,
              cons_list(index_uni(i),
                cons_list(index_min_max(1, nvars), nil_index_list())),
              to_row_vector(coefs), "assigning variable coefs_rcens");}
        } 
        current_statement__ = 37;
        if (logical_gt(nextern, 0)) {
          current_statement__ = 35;
          for (int i = 1; i <= nextern; ++i) {
            current_statement__ = 33;
            assign(coefs_extern,
              cons_list(index_uni(i),
                cons_list(index_min_max(1, nvars), nil_index_list())),
              to_row_vector(coefs), "assigning variable coefs_extern");}
        } 
        current_statement__ = 48;
        for (int j = 1; j <= nvars; ++j) {
          current_statement__ = 40;
          if (logical_gt(nevent, 0)) {
            current_statement__ = 38;
            assign(b_event,
              cons_list(index_min_max(1, nevent),
                cons_list(index_uni(j), nil_index_list())),
              rep_vector(0, nevent), "assigning variable b_event");
          } 
          current_statement__ = 43;
          if (logical_gt(nrcens, 0)) {
            current_statement__ = 41;
            assign(b_rcens,
              cons_list(index_min_max(1, nrcens),
                cons_list(index_uni(j), nil_index_list())),
              rep_vector(0, nrcens), "assigning variable b_rcens");
          } 
          current_statement__ = 46;
          if (logical_gt(nextern, 0)) {
            current_statement__ = 44;
            assign(b_extern,
              cons_list(index_min_max(1, nextern),
                cons_list(index_uni(j), nil_index_list())),
              rep_vector(0, nextern), "assigning variable b_extern");
          } }
        current_statement__ = 53;
        for (int j = 1; j <= (nvars - 1); ++j) {
          current_statement__ = 51;
          if (logical_gt(ncovs, 0)) {
            current_statement__ = 49;
            assign(b_np,
              cons_list(index_min_max(1, ncovs),
                cons_list(index_uni(j), nil_index_list())),
              rep_vector(0, ncovs), "assigning variable b_np");
          } }
        current_statement__ = 54;
        ssd = 0;
      }
      {
        current_statement__ = 98;
        validate_non_negative_index("alpha_event", "nevent", nevent);
        Eigen::Matrix<local_scalar_t__, -1, 1> alpha_event;
        alpha_event = Eigen::Matrix<local_scalar_t__, -1, 1>(nevent);
        stan::math::fill(alpha_event, DUMMY_VAR__);
        
        current_statement__ = 100;
        validate_non_negative_index("alpha_rcens", "nrcens", nrcens);
        Eigen::Matrix<local_scalar_t__, -1, 1> alpha_rcens;
        alpha_rcens = Eigen::Matrix<local_scalar_t__, -1, 1>(nrcens);
        stan::math::fill(alpha_rcens, DUMMY_VAR__);
        
        current_statement__ = 102;
        validate_non_negative_index("alpha_extern", "nextern", nextern);
        Eigen::Matrix<local_scalar_t__, -1, 1> alpha_extern;
        alpha_extern = Eigen::Matrix<local_scalar_t__, -1, 1>(nextern);
        stan::math::fill(alpha_extern, DUMMY_VAR__);
        
        local_scalar_t__ dummy;
        dummy = DUMMY_VAR__;
        
        local_scalar_t__ cp;
        cp = DUMMY_VAR__;
        
        current_statement__ = 106;
        validate_non_negative_index("p_ext_stop", "nextern", nextern);
        Eigen::Matrix<local_scalar_t__, -1, 1> p_ext_stop;
        p_ext_stop = Eigen::Matrix<local_scalar_t__, -1, 1>(nextern);
        stan::math::fill(p_ext_stop, DUMMY_VAR__);
        
        current_statement__ = 108;
        validate_non_negative_index("p_ext_start", "nextern", nextern);
        Eigen::Matrix<local_scalar_t__, -1, 1> p_ext_start;
        p_ext_start = Eigen::Matrix<local_scalar_t__, -1, 1>(nextern);
        stan::math::fill(p_ext_start, DUMMY_VAR__);
        
        current_statement__ = 110;
        validate_non_negative_index("pcure_event", "nevent", nevent);
        Eigen::Matrix<local_scalar_t__, -1, 1> pcure_event;
        pcure_event = Eigen::Matrix<local_scalar_t__, -1, 1>(nevent);
        stan::math::fill(pcure_event, DUMMY_VAR__);
        
        current_statement__ = 112;
        validate_non_negative_index("pcure_rcens", "nrcens", nrcens);
        Eigen::Matrix<local_scalar_t__, -1, 1> pcure_rcens;
        pcure_rcens = Eigen::Matrix<local_scalar_t__, -1, 1>(nrcens);
        stan::math::fill(pcure_rcens, DUMMY_VAR__);
        
        current_statement__ = 114;
        validate_non_negative_index("pcure_extern", "nextern", nextern);
        Eigen::Matrix<local_scalar_t__, -1, 1> pcure_extern;
        pcure_extern = Eigen::Matrix<local_scalar_t__, -1, 1>(nextern);
        stan::math::fill(pcure_extern, DUMMY_VAR__);
        
        current_statement__ = 117;
        if (logical_gt(nevent, 0)) {
          current_statement__ = 116;
          assign(alpha_event, nil_index_list(),
            rep_vector((prior_hscale[(1 - 1)] + gamma[(1 - 1)]), nevent),
            "assigning variable alpha_event");
        } 
        current_statement__ = 119;
        if (logical_gt(nrcens, 0)) {
          current_statement__ = 118;
          assign(alpha_rcens, nil_index_list(),
            rep_vector((prior_hscale[(1 - 1)] + gamma[(1 - 1)]), nrcens),
            "assigning variable alpha_rcens");
        } 
        current_statement__ = 121;
        if (logical_gt(nextern, 0)) {
          current_statement__ = 120;
          assign(alpha_extern, nil_index_list(),
            rep_vector((prior_hscale[(1 - 1)] + gamma[(1 - 1)]), nextern),
            "assigning variable alpha_extern");
        } 
        current_statement__ = 129;
        if (logical_gt(ncovs, 0)) {
          current_statement__ = 123;
          if (logical_gt(nevent, 0)) {
            current_statement__ = 122;
            assign(alpha_event, nil_index_list(),
              add(stan::model::deep_copy(alpha_event),
                multiply(x_event, loghr)), "assigning variable alpha_event");
          } 
          current_statement__ = 125;
          if (logical_gt(nrcens, 0)) {
            current_statement__ = 124;
            assign(alpha_rcens, nil_index_list(),
              add(stan::model::deep_copy(alpha_rcens),
                multiply(x_rcens, loghr)), "assigning variable alpha_rcens");
          } 
          current_statement__ = 127;
          if (logical_gt(nextern, 0)) {
            current_statement__ = 126;
            assign(alpha_extern, nil_index_list(),
              add(stan::model::deep_copy(alpha_extern),
                multiply(x_ext, loghr)), "assigning variable alpha_extern");
          } 
        } 
        current_statement__ = 132;
        if (cure) {
          current_statement__ = 131;
          cp = pcure[(1 - 1)];
        } else {
          current_statement__ = 130;
          cp = 0;
        }
        current_statement__ = 133;
        assign(pcure_event, nil_index_list(), rep_vector(cp, nevent),
          "assigning variable pcure_event");
        current_statement__ = 134;
        assign(pcure_rcens, nil_index_list(), rep_vector(cp, nrcens),
          "assigning variable pcure_rcens");
        current_statement__ = 135;
        assign(pcure_extern, nil_index_list(), rep_vector(cp, nextern),
          "assigning variable pcure_extern");
        current_statement__ = 143;
        if (logical_gt(ncurecovs, 0)) {
          current_statement__ = 137;
          if (logical_gt(nevent, 0)) {
            current_statement__ = 136;
            assign(pcure_event, nil_index_list(),
              inv_logit(
                add(logit(stan::model::deep_copy(pcure_event)),
                  multiply(xcure_event, logor_cure))),
              "assigning variable pcure_event");
          } 
          current_statement__ = 139;
          if (logical_gt(nrcens, 0)) {
            current_statement__ = 138;
            assign(pcure_rcens, nil_index_list(),
              inv_logit(
                add(logit(stan::model::deep_copy(pcure_rcens)),
                  multiply(xcure_rcens, logor_cure))),
              "assigning variable pcure_rcens");
          } 
          current_statement__ = 141;
          if (logical_gt(nextern, 0)) {
            current_statement__ = 140;
            assign(pcure_extern, nil_index_list(),
              inv_logit(
                add(logit(stan::model::deep_copy(pcure_extern)),
                  multiply(xcure_ext, logor_cure))),
              "assigning variable pcure_extern");
          } 
        } 
        current_statement__ = 145;
        if (logical_gt(nevent, 0)) {
          current_statement__ = 144;
          lp_accum__.add(
            log_dens(alpha_event, basis_event, coefs_event, cure,
              pcure_event, ibasis_event, modelid, relative,
              backhaz_event, pstream__));
        } 
        current_statement__ = 147;
        if (logical_gt(nrcens, 0)) {
          current_statement__ = 146;
          lp_accum__.add(
            log_surv(alpha_rcens, ibasis_rcens, coefs_rcens, cure,
              pcure_rcens, modelid, pstream__));
        } 
        current_statement__ = 152;
        if (logical_gt(nextern, 0)) {
          current_statement__ = 148;
          assign(p_ext_stop, nil_index_list(),
            elt_multiply(
              stan::math::exp(
                log_surv(alpha_extern, ibasis_ext_stop, coefs_extern, cure,
                  pcure_extern, modelid, pstream__)), backsurv_ext_stop),
            "assigning variable p_ext_stop");
          current_statement__ = 149;
          assign(p_ext_start, nil_index_list(),
            elt_multiply(
              stan::math::exp(
                log_surv(alpha_extern, ibasis_ext_start, coefs_extern, cure,
                  pcure_extern, modelid, pstream__)), backsurv_ext_start),
            "assigning variable p_ext_start");
          current_statement__ = 150;
          lp_accum__.add(
            binomial_lpmf<false>(r_ext, n_ext,
              elt_divide(p_ext_stop, p_ext_start)));
        } 
        current_statement__ = 153;
        dummy = loghaz_lp<false>(gamma[(1 - 1)], prior_hscale_dist, 0,
                  prior_hscale[(2 - 1)],
                  prior_hscale[(3 - 1)], lp__, lp_accum__, pstream__);
        current_statement__ = 154;
        dummy = loghr_lp<false>(loghr, prior_loghr_dist,
                  prior_loghr_location, prior_loghr_scale,
                  prior_loghr_df, lp__, lp_accum__, pstream__);
        current_statement__ = 155;
        lp_accum__.add(logistic_lpdf<propto__>(b_err, 0, 1));
        current_statement__ = 158;
        if (cure) {
          current_statement__ = 156;
          lp_accum__.add(
            beta_lpdf<propto__>(pcure, prior_cure[(1 - 1)],
              prior_cure[(2 - 1)]));
        } 
        current_statement__ = 161;
        if (logical_gt(ncurecovs, 0)) {
          current_statement__ = 159;
          dummy = loghr_lp<false>(logor_cure, prior_logor_cure_dist,
                    prior_logor_cure_location, prior_logor_cure_scale,
                    prior_logor_cure_df, lp__, lp_accum__, pstream__);
        } 
        current_statement__ = 164;
        if (est_hsd) {
          current_statement__ = 162;
          lp_accum__.add(
            gamma_lpdf<propto__>(hsd, prior_hsd[(1 - 1)], prior_hsd[(2 - 1)]));
        } 
        current_statement__ = 170;
        if ((primitive_value(logical_gt(ncovs, 0)) && primitive_value(
            nonprop))) {
          current_statement__ = 165;
          lp_accum__.add(
            gamma_lpdf<propto__>(hrsd,
              rvalue(prior_hrsd,
                cons_list(index_omni(),
                  cons_list(index_uni(1), nil_index_list())), "prior_hrsd"),
              rvalue(prior_hrsd,
                cons_list(index_omni(),
                  cons_list(index_uni(2), nil_index_list())), "prior_hrsd")));
          current_statement__ = 168;
          for (int i = 1; i <= ncovs; ++i) {
            current_statement__ = 166;
            lp_accum__.add(
              std_normal_lpdf<propto__>(
                rvalue(nperr,
                  cons_list(index_uni(i),
                    cons_list(index_min_max(1, (nvars - 1)),
                      nil_index_list())), "nperr")));}
        } 
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr>
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "model_survextrap_namespace::write_array";
(void) function__;  // suppress unused var warning
    (void) function__;  // suppress unused var warning
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      std::vector<double> gamma;
      gamma = std::vector<double>(1, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 1;
      for (int sym1__ = 1; sym1__ <= 1; ++sym1__) {
        current_statement__ = 1;
        assign(gamma, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable gamma");}
      Eigen::Matrix<double, -1, 1> loghr;
      loghr = Eigen::Matrix<double, -1, 1>(ncovs);
      stan::math::fill(loghr, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 2;
      loghr = in__.vector(ncovs);
      Eigen::Matrix<double, -1, 1> b_err;
      b_err = Eigen::Matrix<double, -1, 1>(b_err_1dim__);
      stan::math::fill(b_err, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 3;
      b_err = in__.vector(b_err_1dim__);
      Eigen::Matrix<double, -1, 1> hsd;
      hsd = Eigen::Matrix<double, -1, 1>(est_hsd);
      stan::math::fill(hsd, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 4;
      hsd = in__.vector(est_hsd);
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= est_hsd; ++sym1__) {
        current_statement__ = 4;
        assign(hsd, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_constrain(hsd[(sym1__ - 1)], 0),
          "assigning variable hsd");}
      Eigen::Matrix<double, -1, 1> pcure;
      pcure = Eigen::Matrix<double, -1, 1>(cure);
      stan::math::fill(pcure, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 5;
      pcure = in__.vector(cure);
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= cure; ++sym1__) {
        current_statement__ = 5;
        assign(pcure, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lub_constrain(pcure[(sym1__ - 1)], 0, 1),
          "assigning variable pcure");}
      Eigen::Matrix<double, -1, 1> logor_cure;
      logor_cure = Eigen::Matrix<double, -1, 1>(ncurecovs);
      stan::math::fill(logor_cure, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 6;
      logor_cure = in__.vector(ncurecovs);
      Eigen::Matrix<double, -1, 1> hrsd;
      hrsd = Eigen::Matrix<double, -1, 1>(hrsd_1dim__);
      stan::math::fill(hrsd, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 7;
      hrsd = in__.vector(hrsd_1dim__);
      current_statement__ = 7;
      for (int sym1__ = 1; sym1__ <= hrsd_1dim__; ++sym1__) {
        current_statement__ = 7;
        assign(hrsd, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_constrain(hrsd[(sym1__ - 1)], 0),
          "assigning variable hrsd");}
      Eigen::Matrix<double, -1, -1> nperr;
      nperr = Eigen::Matrix<double, -1, -1>(nperr_1dim__, nperr_2dim__);
      stan::math::fill(nperr, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 8;
      nperr = in__.matrix(nperr_1dim__, nperr_2dim__);
      Eigen::Matrix<double, -1, 1> b;
      b = Eigen::Matrix<double, -1, 1>(nvars);
      stan::math::fill(b, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> coefs;
      coefs = Eigen::Matrix<double, -1, 1>(nvars);
      stan::math::fill(coefs, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, -1> coefs_event;
      coefs_event = Eigen::Matrix<double, -1, -1>(nevent, nvars);
      stan::math::fill(coefs_event, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, -1> coefs_rcens;
      coefs_rcens = Eigen::Matrix<double, -1, -1>(nrcens, nvars);
      stan::math::fill(coefs_rcens, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, -1> coefs_extern;
      coefs_extern = Eigen::Matrix<double, -1, -1>(nextern, nvars);
      stan::math::fill(coefs_extern, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, -1> b_event;
      b_event = Eigen::Matrix<double, -1, -1>(nevent, nvars);
      stan::math::fill(b_event, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, -1> b_rcens;
      b_rcens = Eigen::Matrix<double, -1, -1>(nrcens, nvars);
      stan::math::fill(b_rcens, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, -1> b_extern;
      b_extern = Eigen::Matrix<double, -1, -1>(nextern, nvars);
      stan::math::fill(b_extern, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, -1> b_np;
      b_np = Eigen::Matrix<double, -1, -1>(ncovs, b_np_2dim__);
      stan::math::fill(b_np, std::numeric_limits<double>::quiet_NaN());
      
      double ssd;
      ssd = std::numeric_limits<double>::quiet_NaN();
      
      for (int sym1__ = 1; sym1__ <= 1; ++sym1__) {
        vars__.emplace_back(gamma[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= ncovs; ++sym1__) {
        vars__.emplace_back(loghr[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= b_err_1dim__; ++sym1__) {
        vars__.emplace_back(b_err[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= est_hsd; ++sym1__) {
        vars__.emplace_back(hsd[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= cure; ++sym1__) {
        vars__.emplace_back(pcure[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= ncurecovs; ++sym1__) {
        vars__.emplace_back(logor_cure[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= hrsd_1dim__; ++sym1__) {
        vars__.emplace_back(hrsd[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= nperr_2dim__; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= nperr_1dim__; ++sym2__) {
          vars__.emplace_back(
            rvalue(nperr,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())), "nperr"));}}
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 94;
      if ((primitive_value(logical_gt(ncovs, 0)) && primitive_value(nonprop))) {
        current_statement__ = 58;
        for (int r = 1; r <= ncovs; ++r) {
          current_statement__ = 56;
          assign(b_np,
            cons_list(index_uni(r),
              cons_list(index_min_max(1, (nvars - 1)), nil_index_list())),
            multiply(hrsd[(r - 1)],
              rvalue(nperr,
                cons_list(index_uni(r),
                  cons_list(index_min_max(1, (nvars - 1)), nil_index_list())),
                "nperr")), "assigning variable b_np");}
        current_statement__ = 63;
        if (est_hsd) {
          current_statement__ = 61;
          ssd = hsd[(1 - 1)];
        } else {
          current_statement__ = 59;
          ssd = hsd_fixed[(1 - 1)];
        }
        current_statement__ = 64;
        assign(b, nil_index_list(),
          append_row(0, add(b_mean, multiply(b_err, ssd))),
          "assigning variable b");
        current_statement__ = 65;
        assign(coefs, nil_index_list(), softmax(b),
          "assigning variable coefs");
        current_statement__ = 74;
        if (logical_gt(nevent, 0)) {
          current_statement__ = 66;
          assign(b_event,
            cons_list(index_min_max(1, nevent),
              cons_list(index_uni(1), nil_index_list())),
            rep_vector(0, nevent), "assigning variable b_event");
          current_statement__ = 69;
          for (int j = 1; j <= (nvars - 1); ++j) {
            current_statement__ = 67;
            assign(b_event,
              cons_list(index_min_max(1, nevent),
                cons_list(index_uni((j + 1)), nil_index_list())),
              add(
                add(b_mean[(j - 1)],
                  multiply(x_event,
                    rvalue(b_np,
                      cons_list(index_omni(),
                        cons_list(index_uni(j), nil_index_list())), "b_np"))),
                (b_err[(j - 1)] * ssd)), "assigning variable b_event");}
          current_statement__ = 72;
          for (int i = 1; i <= nevent; ++i) {
            current_statement__ = 70;
            assign(coefs_event,
              cons_list(index_uni(i),
                cons_list(index_min_max(1, nvars), nil_index_list())),
              to_row_vector(
                softmax(
                  to_vector(
                    rvalue(b_event,
                      cons_list(index_uni(i),
                        cons_list(index_min_max(1, nvars), nil_index_list())),
                      "b_event")))), "assigning variable coefs_event");}
        } 
        current_statement__ = 83;
        if (logical_gt(nrcens, 0)) {
          current_statement__ = 75;
          assign(b_rcens,
            cons_list(index_min_max(1, nrcens),
              cons_list(index_uni(1), nil_index_list())),
            rep_vector(0, nrcens), "assigning variable b_rcens");
          current_statement__ = 78;
          for (int j = 1; j <= (nvars - 1); ++j) {
            current_statement__ = 76;
            assign(b_rcens,
              cons_list(index_min_max(1, nrcens),
                cons_list(index_uni((j + 1)), nil_index_list())),
              add(
                add(b_mean[(j - 1)],
                  multiply(x_rcens,
                    rvalue(b_np,
                      cons_list(index_omni(),
                        cons_list(index_uni(j), nil_index_list())), "b_np"))),
                (b_err[(j - 1)] * ssd)), "assigning variable b_rcens");}
          current_statement__ = 81;
          for (int i = 1; i <= nrcens; ++i) {
            current_statement__ = 79;
            assign(coefs_rcens,
              cons_list(index_uni(i),
                cons_list(index_min_max(1, nvars), nil_index_list())),
              to_row_vector(
                softmax(
                  to_vector(
                    rvalue(b_rcens,
                      cons_list(index_uni(i),
                        cons_list(index_min_max(1, nvars), nil_index_list())),
                      "b_rcens")))), "assigning variable coefs_rcens");}
        } 
        current_statement__ = 92;
        if (logical_gt(nextern, 0)) {
          current_statement__ = 84;
          assign(b_extern,
            cons_list(index_min_max(1, nextern),
              cons_list(index_uni(1), nil_index_list())),
            rep_vector(0, nextern), "assigning variable b_extern");
          current_statement__ = 87;
          for (int j = 1; j <= (nvars - 1); ++j) {
            current_statement__ = 85;
            assign(b_extern,
              cons_list(index_min_max(1, nextern),
                cons_list(index_uni((j + 1)), nil_index_list())),
              add(
                add(b_mean[(j - 1)],
                  multiply(x_ext,
                    rvalue(b_np,
                      cons_list(index_omni(),
                        cons_list(index_uni(j), nil_index_list())), "b_np"))),
                (b_err[(j - 1)] * ssd)), "assigning variable b_extern");}
          current_statement__ = 90;
          for (int i = 1; i <= nextern; ++i) {
            current_statement__ = 88;
            assign(coefs_extern,
              cons_list(index_uni(i),
                cons_list(index_min_max(1, nvars), nil_index_list())),
              to_row_vector(
                softmax(
                  to_vector(
                    rvalue(b_extern,
                      cons_list(index_uni(i),
                        cons_list(index_min_max(1, nvars), nil_index_list())),
                      "b_extern")))), "assigning variable coefs_extern");}
        } 
      } else {
        current_statement__ = 21;
        if (est_hsd) {
          current_statement__ = 20;
          assign(b, nil_index_list(),
            append_row(0, add(b_mean, multiply(b_err, hsd[(1 - 1)]))),
            "assigning variable b");
        } else {
          current_statement__ = 19;
          assign(b, nil_index_list(),
            append_row(0, add(b_mean, multiply(b_err, hsd_fixed[(1 - 1)]))),
            "assigning variable b");
        }
        current_statement__ = 22;
        assign(coefs, nil_index_list(), softmax(b),
          "assigning variable coefs");
        current_statement__ = 27;
        if (logical_gt(nevent, 0)) {
          current_statement__ = 25;
          for (int i = 1; i <= nevent; ++i) {
            current_statement__ = 23;
            assign(coefs_event,
              cons_list(index_uni(i),
                cons_list(index_min_max(1, nvars), nil_index_list())),
              to_row_vector(coefs), "assigning variable coefs_event");}
        } 
        current_statement__ = 32;
        if (logical_gt(nrcens, 0)) {
          current_statement__ = 30;
          for (int i = 1; i <= nrcens; ++i) {
            current_statement__ = 28;
            assign(coefs_rcens,
              cons_list(index_uni(i),
                cons_list(index_min_max(1, nvars), nil_index_list())),
              to_row_vector(coefs), "assigning variable coefs_rcens");}
        } 
        current_statement__ = 37;
        if (logical_gt(nextern, 0)) {
          current_statement__ = 35;
          for (int i = 1; i <= nextern; ++i) {
            current_statement__ = 33;
            assign(coefs_extern,
              cons_list(index_uni(i),
                cons_list(index_min_max(1, nvars), nil_index_list())),
              to_row_vector(coefs), "assigning variable coefs_extern");}
        } 
        current_statement__ = 48;
        for (int j = 1; j <= nvars; ++j) {
          current_statement__ = 40;
          if (logical_gt(nevent, 0)) {
            current_statement__ = 38;
            assign(b_event,
              cons_list(index_min_max(1, nevent),
                cons_list(index_uni(j), nil_index_list())),
              rep_vector(0, nevent), "assigning variable b_event");
          } 
          current_statement__ = 43;
          if (logical_gt(nrcens, 0)) {
            current_statement__ = 41;
            assign(b_rcens,
              cons_list(index_min_max(1, nrcens),
                cons_list(index_uni(j), nil_index_list())),
              rep_vector(0, nrcens), "assigning variable b_rcens");
          } 
          current_statement__ = 46;
          if (logical_gt(nextern, 0)) {
            current_statement__ = 44;
            assign(b_extern,
              cons_list(index_min_max(1, nextern),
                cons_list(index_uni(j), nil_index_list())),
              rep_vector(0, nextern), "assigning variable b_extern");
          } }
        current_statement__ = 53;
        for (int j = 1; j <= (nvars - 1); ++j) {
          current_statement__ = 51;
          if (logical_gt(ncovs, 0)) {
            current_statement__ = 49;
            assign(b_np,
              cons_list(index_min_max(1, ncovs),
                cons_list(index_uni(j), nil_index_list())),
              rep_vector(0, ncovs), "assigning variable b_np");
          } }
        current_statement__ = 54;
        ssd = 0;
      }
      if (emit_transformed_parameters__) {
        for (int sym1__ = 1; sym1__ <= nvars; ++sym1__) {
          vars__.emplace_back(b[(sym1__ - 1)]);}
        for (int sym1__ = 1; sym1__ <= nvars; ++sym1__) {
          vars__.emplace_back(coefs[(sym1__ - 1)]);}
        for (int sym1__ = 1; sym1__ <= nvars; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= nevent; ++sym2__) {
            vars__.emplace_back(
              rvalue(coefs_event,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())),
                "coefs_event"));}}
        for (int sym1__ = 1; sym1__ <= nvars; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= nrcens; ++sym2__) {
            vars__.emplace_back(
              rvalue(coefs_rcens,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())),
                "coefs_rcens"));}}
        for (int sym1__ = 1; sym1__ <= nvars; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= nextern; ++sym2__) {
            vars__.emplace_back(
              rvalue(coefs_extern,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())),
                "coefs_extern"));}}
        for (int sym1__ = 1; sym1__ <= nvars; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= nevent; ++sym2__) {
            vars__.emplace_back(
              rvalue(b_event,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())), "b_event"));
          }}
        for (int sym1__ = 1; sym1__ <= nvars; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= nrcens; ++sym2__) {
            vars__.emplace_back(
              rvalue(b_rcens,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())), "b_rcens"));
          }}
        for (int sym1__ = 1; sym1__ <= nvars; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= nextern; ++sym2__) {
            vars__.emplace_back(
              rvalue(b_extern,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())),
                "b_extern"));}}
        for (int sym1__ = 1; sym1__ <= b_np_2dim__; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= ncovs; ++sym2__) {
            vars__.emplace_back(
              rvalue(b_np,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())), "b_np"));}
        }
        vars__.emplace_back(ssd);
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      double alpha;
      alpha = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 95;
      alpha = (prior_hscale[(1 - 1)] + gamma[(1 - 1)]);
      Eigen::Matrix<double, -1, 1> hr;
      hr = Eigen::Matrix<double, -1, 1>(ncovs);
      stan::math::fill(hr, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 96;
      assign(hr, nil_index_list(), stan::math::exp(loghr),
        "assigning variable hr");
      Eigen::Matrix<double, -1, 1> or_cure;
      or_cure = Eigen::Matrix<double, -1, 1>(ncurecovs);
      stan::math::fill(or_cure, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 97;
      assign(or_cure, nil_index_list(), stan::math::exp(logor_cure),
        "assigning variable or_cure");
      vars__.emplace_back(alpha);
      for (int sym1__ = 1; sym1__ <= ncovs; ++sym1__) {
        vars__.emplace_back(hr[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= ncurecovs; ++sym1__) {
        vars__.emplace_back(or_cure[(sym1__ - 1)]);}
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, stan::require_std_vector_t<VecVar>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void transform_inits_impl(const stan::io::var_context& context__,
                                   VecI& params_i__, VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      std::vector<double> gamma;
      gamma = std::vector<double>(1, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 1;
      assign(gamma, nil_index_list(), context__.vals_r("gamma"),
        "assigning variable gamma");
      Eigen::Matrix<double, -1, 1> loghr;
      loghr = Eigen::Matrix<double, -1, 1>(ncovs);
      stan::math::fill(loghr, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> loghr_flat__;
        current_statement__ = 2;
        assign(loghr_flat__, nil_index_list(), context__.vals_r("loghr"),
          "assigning variable loghr_flat__");
        current_statement__ = 2;
        pos__ = 1;
        current_statement__ = 2;
        for (int sym1__ = 1; sym1__ <= ncovs; ++sym1__) {
          current_statement__ = 2;
          assign(loghr, cons_list(index_uni(sym1__), nil_index_list()),
            loghr_flat__[(pos__ - 1)], "assigning variable loghr");
          current_statement__ = 2;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> b_err;
      b_err = Eigen::Matrix<double, -1, 1>(b_err_1dim__);
      stan::math::fill(b_err, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> b_err_flat__;
        current_statement__ = 3;
        assign(b_err_flat__, nil_index_list(), context__.vals_r("b_err"),
          "assigning variable b_err_flat__");
        current_statement__ = 3;
        pos__ = 1;
        current_statement__ = 3;
        for (int sym1__ = 1; sym1__ <= b_err_1dim__; ++sym1__) {
          current_statement__ = 3;
          assign(b_err, cons_list(index_uni(sym1__), nil_index_list()),
            b_err_flat__[(pos__ - 1)], "assigning variable b_err");
          current_statement__ = 3;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> hsd;
      hsd = Eigen::Matrix<double, -1, 1>(est_hsd);
      stan::math::fill(hsd, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> hsd_flat__;
        current_statement__ = 4;
        assign(hsd_flat__, nil_index_list(), context__.vals_r("hsd"),
          "assigning variable hsd_flat__");
        current_statement__ = 4;
        pos__ = 1;
        current_statement__ = 4;
        for (int sym1__ = 1; sym1__ <= est_hsd; ++sym1__) {
          current_statement__ = 4;
          assign(hsd, cons_list(index_uni(sym1__), nil_index_list()),
            hsd_flat__[(pos__ - 1)], "assigning variable hsd");
          current_statement__ = 4;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> hsd_free__;
      hsd_free__ = Eigen::Matrix<double, -1, 1>(est_hsd);
      stan::math::fill(hsd_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 4;
      for (int sym1__ = 1; sym1__ <= est_hsd; ++sym1__) {
        current_statement__ = 4;
        assign(hsd_free__, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_free(hsd[(sym1__ - 1)], 0),
          "assigning variable hsd_free__");}
      Eigen::Matrix<double, -1, 1> pcure;
      pcure = Eigen::Matrix<double, -1, 1>(cure);
      stan::math::fill(pcure, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> pcure_flat__;
        current_statement__ = 5;
        assign(pcure_flat__, nil_index_list(), context__.vals_r("pcure"),
          "assigning variable pcure_flat__");
        current_statement__ = 5;
        pos__ = 1;
        current_statement__ = 5;
        for (int sym1__ = 1; sym1__ <= cure; ++sym1__) {
          current_statement__ = 5;
          assign(pcure, cons_list(index_uni(sym1__), nil_index_list()),
            pcure_flat__[(pos__ - 1)], "assigning variable pcure");
          current_statement__ = 5;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> pcure_free__;
      pcure_free__ = Eigen::Matrix<double, -1, 1>(cure);
      stan::math::fill(pcure_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= cure; ++sym1__) {
        current_statement__ = 5;
        assign(pcure_free__, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lub_free(pcure[(sym1__ - 1)], 0, 1),
          "assigning variable pcure_free__");}
      Eigen::Matrix<double, -1, 1> logor_cure;
      logor_cure = Eigen::Matrix<double, -1, 1>(ncurecovs);
      stan::math::fill(logor_cure, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> logor_cure_flat__;
        current_statement__ = 6;
        assign(logor_cure_flat__, nil_index_list(),
          context__.vals_r("logor_cure"),
          "assigning variable logor_cure_flat__");
        current_statement__ = 6;
        pos__ = 1;
        current_statement__ = 6;
        for (int sym1__ = 1; sym1__ <= ncurecovs; ++sym1__) {
          current_statement__ = 6;
          assign(logor_cure, cons_list(index_uni(sym1__), nil_index_list()),
            logor_cure_flat__[(pos__ - 1)], "assigning variable logor_cure");
          current_statement__ = 6;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> hrsd;
      hrsd = Eigen::Matrix<double, -1, 1>(hrsd_1dim__);
      stan::math::fill(hrsd, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> hrsd_flat__;
        current_statement__ = 7;
        assign(hrsd_flat__, nil_index_list(), context__.vals_r("hrsd"),
          "assigning variable hrsd_flat__");
        current_statement__ = 7;
        pos__ = 1;
        current_statement__ = 7;
        for (int sym1__ = 1; sym1__ <= hrsd_1dim__; ++sym1__) {
          current_statement__ = 7;
          assign(hrsd, cons_list(index_uni(sym1__), nil_index_list()),
            hrsd_flat__[(pos__ - 1)], "assigning variable hrsd");
          current_statement__ = 7;
          pos__ = (pos__ + 1);}
      }
      Eigen::Matrix<double, -1, 1> hrsd_free__;
      hrsd_free__ = Eigen::Matrix<double, -1, 1>(hrsd_1dim__);
      stan::math::fill(hrsd_free__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 7;
      for (int sym1__ = 1; sym1__ <= hrsd_1dim__; ++sym1__) {
        current_statement__ = 7;
        assign(hrsd_free__, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_free(hrsd[(sym1__ - 1)], 0),
          "assigning variable hrsd_free__");}
      Eigen::Matrix<double, -1, -1> nperr;
      nperr = Eigen::Matrix<double, -1, -1>(nperr_1dim__, nperr_2dim__);
      stan::math::fill(nperr, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> nperr_flat__;
        current_statement__ = 8;
        assign(nperr_flat__, nil_index_list(), context__.vals_r("nperr"),
          "assigning variable nperr_flat__");
        current_statement__ = 8;
        pos__ = 1;
        current_statement__ = 8;
        for (int sym1__ = 1; sym1__ <= nperr_2dim__; ++sym1__) {
          current_statement__ = 8;
          for (int sym2__ = 1; sym2__ <= nperr_1dim__; ++sym2__) {
            current_statement__ = 8;
            assign(nperr,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              nperr_flat__[(pos__ - 1)], "assigning variable nperr");
            current_statement__ = 8;
            pos__ = (pos__ + 1);}}
      }
      for (int sym1__ = 1; sym1__ <= 1; ++sym1__) {
        vars__.emplace_back(gamma[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= ncovs; ++sym1__) {
        vars__.emplace_back(loghr[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= b_err_1dim__; ++sym1__) {
        vars__.emplace_back(b_err[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= est_hsd; ++sym1__) {
        vars__.emplace_back(hsd_free__[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= cure; ++sym1__) {
        vars__.emplace_back(pcure_free__[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= ncurecovs; ++sym1__) {
        vars__.emplace_back(logor_cure[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= hrsd_1dim__; ++sym1__) {
        vars__.emplace_back(hrsd_free__[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= nperr_2dim__; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= nperr_1dim__; ++sym2__) {
          vars__.emplace_back(
            rvalue(nperr,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())), "nperr"));}}
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.clear();
    names__.emplace_back("gamma");
    names__.emplace_back("loghr");
    names__.emplace_back("b_err");
    names__.emplace_back("hsd");
    names__.emplace_back("pcure");
    names__.emplace_back("logor_cure");
    names__.emplace_back("hrsd");
    names__.emplace_back("nperr");
    names__.emplace_back("b");
    names__.emplace_back("coefs");
    names__.emplace_back("coefs_event");
    names__.emplace_back("coefs_rcens");
    names__.emplace_back("coefs_extern");
    names__.emplace_back("b_event");
    names__.emplace_back("b_rcens");
    names__.emplace_back("b_extern");
    names__.emplace_back("b_np");
    names__.emplace_back("ssd");
    names__.emplace_back("alpha");
    names__.emplace_back("hr");
    names__.emplace_back("or_cure");
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.clear();
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(1)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(ncovs)});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(b_err_1dim__)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(est_hsd)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(cure)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(ncurecovs)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(hrsd_1dim__)});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(nperr_1dim__)
                                             ,
                                             static_cast<size_t>(nperr_2dim__)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nvars)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nvars)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nevent),
                                             static_cast<size_t>(nvars)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nrcens),
                                             static_cast<size_t>(nvars)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nextern),
                                             static_cast<size_t>(nvars)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nevent),
                                             static_cast<size_t>(nvars)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nrcens),
                                             static_cast<size_t>(nvars)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nextern),
                                             static_cast<size_t>(nvars)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(ncovs),
                                             static_cast<size_t>(b_np_2dim__)});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(ncovs)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(ncurecovs)});
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= 1; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "gamma" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= ncovs; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "loghr" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= b_err_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "b_err" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= est_hsd; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "hsd" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= cure; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "pcure" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= ncurecovs; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "logor_cure" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= hrsd_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "hrsd" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= nperr_2dim__; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= nperr_1dim__; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "nperr" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= nvars; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "b" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nvars; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "coefs" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nvars; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nevent; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "coefs_event" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nvars; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nrcens; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "coefs_rcens" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nvars; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nextern; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "coefs_extern" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nvars; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nevent; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "b_event" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nvars; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nrcens; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "b_rcens" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nvars; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nextern; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "b_extern" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= b_np_2dim__; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= ncovs; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "b_np" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      param_names__.emplace_back(std::string() + "ssd");
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "alpha");
      for (int sym1__ = 1; sym1__ <= ncovs; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "hr" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= ncurecovs; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "or_cure" + '.' + std::to_string(sym1__));
        }}
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= 1; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "gamma" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= ncovs; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "loghr" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= b_err_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "b_err" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= est_hsd; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "hsd" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= cure; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "pcure" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= ncurecovs; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "logor_cure" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= hrsd_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "hrsd" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= nperr_2dim__; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= nperr_1dim__; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "nperr" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          }}
      }}
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= nvars; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "b" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nvars; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "coefs" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nvars; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nevent; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "coefs_event" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nvars; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nrcens; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "coefs_rcens" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nvars; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nextern; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "coefs_extern" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nvars; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nevent; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "b_event" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nvars; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nrcens; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "b_rcens" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nvars; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nextern; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "b_extern" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= b_np_2dim__; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= ncovs; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "b_np" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      param_names__.emplace_back(std::string() + "ssd");
    }
    
    if (emit_generated_quantities__) {
      param_names__.emplace_back(std::string() + "alpha");
      for (int sym1__ = 1; sym1__ <= ncovs; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "hr" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= ncurecovs; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "or_cure" + '.' + std::to_string(sym1__));
        }}
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"gamma\",\"type\":{\"name\":\"array\",\"length\":" << 1 << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"loghr\",\"type\":{\"name\":\"vector\",\"length\":" << ncovs << "},\"block\":\"parameters\"},{\"name\":\"b_err\",\"type\":{\"name\":\"vector\",\"length\":" << b_err_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"hsd\",\"type\":{\"name\":\"vector\",\"length\":" << est_hsd << "},\"block\":\"parameters\"},{\"name\":\"pcure\",\"type\":{\"name\":\"vector\",\"length\":" << cure << "},\"block\":\"parameters\"},{\"name\":\"logor_cure\",\"type\":{\"name\":\"vector\",\"length\":" << ncurecovs << "},\"block\":\"parameters\"},{\"name\":\"hrsd\",\"type\":{\"name\":\"vector\",\"length\":" << hrsd_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"nperr\",\"type\":{\"name\":\"matrix\",\"rows\":" << nperr_1dim__ << ",\"cols\":" << nperr_2dim__ << "},\"block\":\"parameters\"},{\"name\":\"b\",\"type\":{\"name\":\"vector\",\"length\":" << nvars << "},\"block\":\"transformed_parameters\"},{\"name\":\"coefs\",\"type\":{\"name\":\"vector\",\"length\":" << nvars << "},\"block\":\"transformed_parameters\"},{\"name\":\"coefs_event\",\"type\":{\"name\":\"matrix\",\"rows\":" << nevent << ",\"cols\":" << nvars << "},\"block\":\"transformed_parameters\"},{\"name\":\"coefs_rcens\",\"type\":{\"name\":\"matrix\",\"rows\":" << nrcens << ",\"cols\":" << nvars << "},\"block\":\"transformed_parameters\"},{\"name\":\"coefs_extern\",\"type\":{\"name\":\"matrix\",\"rows\":" << nextern << ",\"cols\":" << nvars << "},\"block\":\"transformed_parameters\"},{\"name\":\"b_event\",\"type\":{\"name\":\"matrix\",\"rows\":" << nevent << ",\"cols\":" << nvars << "},\"block\":\"transformed_parameters\"},{\"name\":\"b_rcens\",\"type\":{\"name\":\"matrix\",\"rows\":" << nrcens << ",\"cols\":" << nvars << "},\"block\":\"transformed_parameters\"},{\"name\":\"b_extern\",\"type\":{\"name\":\"matrix\",\"rows\":" << nextern << ",\"cols\":" << nvars << "},\"block\":\"transformed_parameters\"},{\"name\":\"b_np\",\"type\":{\"name\":\"matrix\",\"rows\":" << ncovs << ",\"cols\":" << b_np_2dim__ << "},\"block\":\"transformed_parameters\"},{\"name\":\"ssd\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"alpha\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"hr\",\"type\":{\"name\":\"vector\",\"length\":" << ncovs << "},\"block\":\"generated_quantities\"},{\"name\":\"or_cure\",\"type\":{\"name\":\"vector\",\"length\":" << ncurecovs << "},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"gamma\",\"type\":{\"name\":\"array\",\"length\":" << 1 << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"loghr\",\"type\":{\"name\":\"vector\",\"length\":" << ncovs << "},\"block\":\"parameters\"},{\"name\":\"b_err\",\"type\":{\"name\":\"vector\",\"length\":" << b_err_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"hsd\",\"type\":{\"name\":\"vector\",\"length\":" << est_hsd << "},\"block\":\"parameters\"},{\"name\":\"pcure\",\"type\":{\"name\":\"vector\",\"length\":" << cure << "},\"block\":\"parameters\"},{\"name\":\"logor_cure\",\"type\":{\"name\":\"vector\",\"length\":" << ncurecovs << "},\"block\":\"parameters\"},{\"name\":\"hrsd\",\"type\":{\"name\":\"vector\",\"length\":" << hrsd_1dim__ << "},\"block\":\"parameters\"},{\"name\":\"nperr\",\"type\":{\"name\":\"matrix\",\"rows\":" << nperr_1dim__ << ",\"cols\":" << nperr_2dim__ << "},\"block\":\"parameters\"},{\"name\":\"b\",\"type\":{\"name\":\"vector\",\"length\":" << nvars << "},\"block\":\"transformed_parameters\"},{\"name\":\"coefs\",\"type\":{\"name\":\"vector\",\"length\":" << nvars << "},\"block\":\"transformed_parameters\"},{\"name\":\"coefs_event\",\"type\":{\"name\":\"matrix\",\"rows\":" << nevent << ",\"cols\":" << nvars << "},\"block\":\"transformed_parameters\"},{\"name\":\"coefs_rcens\",\"type\":{\"name\":\"matrix\",\"rows\":" << nrcens << ",\"cols\":" << nvars << "},\"block\":\"transformed_parameters\"},{\"name\":\"coefs_extern\",\"type\":{\"name\":\"matrix\",\"rows\":" << nextern << ",\"cols\":" << nvars << "},\"block\":\"transformed_parameters\"},{\"name\":\"b_event\",\"type\":{\"name\":\"matrix\",\"rows\":" << nevent << ",\"cols\":" << nvars << "},\"block\":\"transformed_parameters\"},{\"name\":\"b_rcens\",\"type\":{\"name\":\"matrix\",\"rows\":" << nrcens << ",\"cols\":" << nvars << "},\"block\":\"transformed_parameters\"},{\"name\":\"b_extern\",\"type\":{\"name\":\"matrix\",\"rows\":" << nextern << ",\"cols\":" << nvars << "},\"block\":\"transformed_parameters\"},{\"name\":\"b_np\",\"type\":{\"name\":\"matrix\",\"rows\":" << ncovs << ",\"cols\":" << b_np_2dim__ << "},\"block\":\"transformed_parameters\"},{\"name\":\"ssd\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"alpha\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"hr\",\"type\":{\"name\":\"vector\",\"length\":" << ncovs << "},\"block\":\"generated_quantities\"},{\"name\":\"or_cure\",\"type\":{\"name\":\"vector\",\"length\":" << ncurecovs << "},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      std::vector<double> vars_vec(vars.size());
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i) {
        vars.coeffRef(i) = vars_vec[i];
      }
    }
    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }
    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
  
    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits_impl(context, params_i, params_r_vec, pstream);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i) {
        params_r.coeffRef(i) = params_r_vec[i];
      }
    }
    inline void transform_inits(const stan::io::var_context& context,
                                std::vector<int>& params_i,
                                std::vector<double>& vars,
                                std::ostream* pstream = nullptr) const final {
      transform_inits_impl(context, params_i, vars, pstream);
    }        
};
}
using stan_model = model_survextrap_namespace::model_survextrap;
#ifndef USING_R
// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return model_survextrap_namespace::profiles__;
}
#endif
#endif
